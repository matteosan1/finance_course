\chapter{Portfolio Optimization}
\label{portfolio-optimization}

Portfolio optimization models look for the optimal way to make investments. Usually investors expect either a maximum return for a given level of risk or a given return for a minimum risk so these models are typically based on two criteria: maximization of the expected return and/or minimization of the risk.

While the concept of return is straightforward there are a variety of risk measures. The most popular one is the variance in return and we will mainly focus on it in this Chapter.

Some notations that will be used later are

\begin{itemize}
\tightlist
\item
  portfolio expected return: 
  \begin{equation} 
  	\mathbb{E}(R_{p}) = \sum _{i}w_{i} \mathbb{E}(R_{i}) = \mathbf{w}\cdot \mathbb{E}(\mathbf{R}) = \mathbf{w}^T \mathbb{E}(\mathbf{R})=
      \begin{bmatrix}
      w_1 \\ 
      w_2 \\ 
      \vdots \\
      w_n
      \end{bmatrix}
      \begin{bmatrix}
      \mathbb{E}(R_1) & \mathbb{E}(R_2) & \cdots & \mathbb{E}(R_n)
      \end{bmatrix}
  \end{equation} 
  where \(R_{p}\) is the return on the portfolio, \(R_{i}\) is the return on asset \(i\) and \(w_{i}\) is the weighting of component asset \(i\) (that is, the proportion of asset \(i\) in the portfolio) and \(\sum_{i}w_i = 1\) and \(0 \le w_i \le 1\);
\item
  portfolio return variance:
  \begin{equation}
  \begin{aligned}
  \sigma _{p}^{2} = &\sum _{i}\sum _{j}w_{i}w_{j}\sigma _{ij} = \mathbf{w}^T\Sigma\mathbf{w} =
  \begin{bmatrix}
  w_1 \\ 
  w_2 \\ 
  \vdots \\
  w_n
  \end{bmatrix}
  \begin{bmatrix}
  \sigma_{11} & \sigma_{12} & \cdots & \sigma_{1n} \\
  \sigma_{21} & \sigma_{22} & \cdots & \sigma_{2n} \\
  \vdots & & \\
  \sigma_{n1} & \sigma_{n2} & \cdots & \sigma_{nn} \\
  \end{bmatrix}
  \begin{bmatrix}
  w_1 & w_2 & \cdots & w_n
  \end{bmatrix} =\\ 
  &\begin{bmatrix}
  \sigma_{11} *w_1 + \sigma_{12} *w_2 + \cdots + \sigma_{1n}*w_n \\
  \sigma_{21} *w_1 + \sigma_{22} *w_2  +\cdots + \sigma_{2n}*w_n \\
  \vdots \\
  \sigma_{n1} *w_1 + \sigma_{n2}*w_2 + \cdots + \sigma_{nn}*w_n \\
  \end{bmatrix}
  \begin{bmatrix}
  w_1 & w_2 & \cdots & w_n
  \end{bmatrix}
  \end{aligned}
  \end{equation}
  where \(\sigma\) is the (sample) standard deviation of the periodic returns on an asset, and \(\rho _{ij}\) is the correlation coefficient between the returns on assets \(i\) and \(j\). For a brief introduction to matrices see Chapter~\ref{sec:matrices};
\item
  portfolio return volatility (standard deviation):
  \begin{equation}
  	\sigma _{p}= \sqrt{\sigma _{p}^{2}}
  \end{equation}
\end{itemize}

\section{Modern Portfolio Theory}
\label{the-markowitz-meanvariance-portfolio-model}

Although investors may expect a particular return when buying a stock, they also may be disappointed or pleasantly surprised, because fluctuations in stock prices result in fluctuating returns. 

The Modern Portfolio Theory (MPT), introduced by Markowitz, defines risk as the possibility that actual returns will deviate from expected returns (the degree of potential fluctuation determines the degree of risk).
So it assumes that an investor has two considerations when constructing an investment portfolio: expected return and variance in return (i.e. measure of risk). 

Hence the Markowitz model requires two major information:

\begin{itemize}
\tightlist
\item the estimated expected return for each candidate investment;
\item the covariance matrix of returns, which characterizes not only the individual variability of the return on each investment, but also how each investment's return tends to move with the others (correlation).
\end{itemize}

In the following examples we are going to use real data
from:  AAPL (Apple), AMZN (Amazon), FB (Facebook), GOOG (Google), NFLX (Netflix). It can be downloaded with \texttt{yfinance}. Otherwise it can be directly used from \href{https://raw.githubusercontent.com/matteosan1/finance_course/develop/libro/input_files/portfolio_data.csv}{portfolio\_data.csv}.

\begin{ipython}
import yfinance as yf

proxy = yf.Tickers(['AAPL', 'AMZN', 'FB', 'GOOG', 'NFLX'])
df = proxy.history(start='2014-03-27', end='2018-03-27')['Close']
# uncomment the following line if reading from file
# df = pd.read_csv("portfolio_data.csv", index_col="date")

print (df.head())
\end{ipython}
\begin{ioutput}
                AAPL       AMZN        FB       GOOG      NFLX
date
2014-03-27 17.202097 338.470001 60.970001 556.930969 52.025715
2014-03-28 17.182892 338.290009	60.009998 558.456787 51.267143
2014-03-31 17.179056 336.369995	60.240002 555.445007 50.290001
2014-04-01 17.336205 342.989990	62.619999 565.607117 52.098572
2014-04-02 17.365013 341.959991	62.720001 565.447571 51.840000
\end{ioutput}
 
Data, shown in Figure~\ref{fig:stocks}, is made of the historical series of the closing prices in the last 5 years. 

\begin{figure}[htbp]
\centering
\includegraphics[width=0.7\textwidth]{figures/portfolio_sample}
\caption{Historical series of the closing price of five companies. To compare them, prices have been normalized to the first value in each series}
\label{fig:stocks}
\end{figure}

The main quantities (e.g. daily returns, covariance matrix,\ldots) can be easily computed with \texttt{pandas}.
Variances can be added across time intervals if return in one interval is uncorrelated with those in others. The correlation of returns across time intervals (called \emph{autocorrelation}) is in general close to zero for most assets. This means that variances will grow with the length of the forecast horizon and the risk will grow with the square root of the forecast horizon. 
Thus, a 5\% annual risk is equivalent to a 2.5\% risk over the first quarter or a 10\% risk over four years. 

This relationship can be used to “annualize” risk, i.e. standardize risk numbers to an annual period. The observed daily return standard deviation ($\sigma_{daily}$) can be converted to annual risk according to
\begin{equation}
\sigma_{yearly} = \sigma_{daily}\cdot\sqrt{252}
\end{equation}

\begin{ipython}
daily_returns = df.pct_change()
returns = daily_returns.mean()*252
print (returns)
\end{ipython}
\begin{ioutput}
AAPL    0.240921
AMZN    0.414775
FB      0.263708
GOOG    0.173464
NFLX    0.527628
dtype: float64
\end{ioutput}

\begin{ipython}
covariance = daily_returns.cov()*252
print (covariance)
\end{ipython}
\begin{ioutput}
          AAPL      AMZN        FB      GOOG      NFLX
AAPL  0.051967  0.025182  0.026075  0.022764  0.028064
AMZN  0.025182  0.085876  0.041196  0.039654  0.048576
FB    0.026075  0.041196  0.069723  0.036337  0.044753
GOOG  0.022764  0.039654  0.036337  0.052001  0.040630
NFLX  0.028064  0.048576  0.044753  0.040630  0.178332
\end{ioutput}
    
\subsection{Portfolio Simulation}
In order to "simulate" a portfolio of $n$ assets it is enough to throw $n$ random weights with the only constraint that they had to sum up to 1. 
In Figure~\ref{fig:mc_portfolio} a large number of simulated portfolios, each made of different proportion of the five assets mentioned above, are shown in a return vs volatility plot. 
Note that in these simulation no attempt of any optimization whatsoever has been made yet.

\begin{figure}[hbtp]
\centering
\includegraphics[width=0.7\textwidth]{figures/return_variance}
\caption{Scatter plot of expected return vs volatility of a large number of simulated portfolios.}
\label{fig:mc_portfolio}
\end{figure}

Investors may use \emph{short sales} in their portfolios (a portfolio is short in those stocks with negative weights). 
Although short selling extends the set of possible portfolios we are not going to consider it here.

\section{Optimisation}\label{optimization}

MPT model states that \textbf{the weights of a portfolio should be chosen such that its volatility (or its variance) is minimised, given a certain level of return}. Alternatively weights can be found by maximizing the return given a certain level of risk. 
The application of this model reduces to a minimization problem: given the covariance matrix of the portfolio $\Sigma$, we need to find

\begin{equation}
\underset{\mathbf{w}}{\min}\{\sigma_p^2\} = \underset{\mathbf{w}}{\min}\{\mathbf{w}^T\Sigma\mathbf{w}\}
\end{equation}
with the constraints $\sum_{i}w_i = 1$ , $0 \le w_i \le 1$ and $\mathbf{w}\cdot\mathbf{R}=R_{\textrm{target}}$.

In \texttt{python} we have already seen how to solve minimisation problems (see bootstrapping in Chapter~\ref{sec:swaps-and-bootstrapping}) so it is enough to repeat the same steps:

\begin{itemize}
\tightlist
\item define an objective function (i.e. the portfolio variance);
\item define the set of constraints;
\item set an initial guess for the weights;
\item run the algorithm with \texttt{scipy.optimize.minimize}.
\end{itemize}

\begin{ipython}
import numpy as np
from scipy.optimize import minimize

def sum_weights(w): 
    return np.sum(w) - 1

def min_risk(w, cov):
    return w.T.dot(cov.dot(w))

def target_return(w, returns, target_return): 
    return (returns.dot(w) - target_return)

num_assets = 5
constraints = [{'type': 'eq', 'fun': sum_weights},
               {'type': 'eq', 'fun': target_return, 'args':(returns, 0.25)}] 
bounds = tuple((0, 1) for _ in range(num_assets))
weights = [1./num_assets for _ in range(num_assets)]

opts = minimize(min_risk, weights, args=(covariance,),
                bounds=bounds, constraints=constraints)
print (opts)
print ("Expected portfolio return: {:.3f}".format(returns.dot(opts.x))
\end{ipython}
\begin{ioutput}
     fun: 0.03636340858846002
     jac: array([0.07251946, 0.07721784, 0.07324787, 0.07043841, 0.08025067])
 message: 'Optimization terminated successfully'
    nfev: 48
     nit: 8
    njev: 8
  status: 0
 success: True
       x: array([0.43988165, 0.10839598, 0.12863822, 0.29488199, 0.02820217])
       
Expected portfolio return: 0.250
\end{ioutput}

The optimization recommends to devote about 44\% of the portfolio to AAPL, about 10\% to AMZN, 12\% to FB and so on\ldots The expected return is 25\% as desired, with a variance of about 0.036 or, equivalently, a standard deviation of 0.19.

%In this example we based the model simply on straightforward statistical data derived from daily returns. However it could be possible, rather than just use historical data, to base this estimate on information about expected future performance of the asset.

There is no precise way for an investor to determine the “correct” trade off between risk and return. The desired higher expected return needs to be paid for with higher risk. Thus, one is frequently interested in looking at the relative distribution of the two.
In finance terminology, means to trace the \emph{efficient frontier of return and risk}. This can be done by solving the previous minimization for a variety of target returns.

The following example computes the efficient frontier plot (shown in Fig.~\ref{fig:efficient_frontier}) with the return ranging from 0.20 to 0.45.

\begin{ipython}
results = []    
for target in np.arange(0.20, 0.45, 0.005):
    constraints = ({'type': 'eq', 'fun': sum_weights},
                   {'type': 'eq', 'fun': target_return, 'args':(returns, target)})
    weights = [1./num_assets for _ in range(num_assets)]
    opts = minimize(min_risk, weights, args=(covariance,), 
                    bounds=bounds, constraints=constraints) 
    
    results.append((np.sqrt(opts.x.T.dot(covariance.dot(opts.x))),
                    returns.dot(opts.x))) 
\end{ipython}

\begin{figure}[htb]
\centering
\includegraphics[width=0.7\textwidth]{figures/efficient_frontier}
\caption{Efficient frontier for our example portfolio obtained minimizing the the variance and requiring an expected return between 0.02 and 0.45.}
\label{fig:efficient_frontier}
\end{figure}

\emph{Efficient portfolios} offer investors the highest possible expected return for a given level of risk. 
An investor seeking high expected returns and low volatility should invest only in efficient portfolios and will choose from the set of efficient portfolios based on her risk tolerance.
    
\subsection{Limits of the Markowitz Model}
\label{limits-of-the-markowitz-model}

Despite the significant utility of the Markowitz theory, there are some major limitations in this model:

\begin{enumerate}
\tightlist
\item the tendency to produce extreme portfolios combining extreme shorts with extreme longs. As a result,portfolio managers generally do not trust these extreme weights. This problem is typically caused by
estimation errors in the mean return vector and covariance matrix;
\item the portfolio weights tend to be extremely sensitive to very small changes in the expected returns. For example, even a small increase in the expected return of just one asset can dramatically alter the optimal composition of the entire portfolio;
\item the presence of heavy tails in the return distributions can result in significant errors in covariance estimates as well.
\end{enumerate}

Extensions of the Markowitz model are defined in~\cite{bib:post_modern_theory} and~\cite{bib:black_litterman}, although they are beyond the scope of these lectures. 
    
\subsection{Portfolios with a Risk-Free Asset}
\label{portfolios-with-a-risk-free-asset}

When one of the investments available is a risk-free asset, then the efficient frontier transform to a particularly simple form. The risk–return combinations of the risk-free investment and a risky portfolio lie on a straight line connecting the two investments: the \emph{capital allocation line} (CAL). The slope of the CAL measures the trade off between risk and return: a higher slope means investors receive a higher expected return in exchange for taking on more risk.

The capital allocation line aids investors in choosing how much to invest in a risk-free asset and one or more risky assets.

The simplest example of such kind of portfolios is the one containing only two assets: a risk-free Treasury bill and a stock. Assume that the expected return of the Treasury bill is \(\mathbb{E}(R_f)=3\%\) (its risk is 0\%). Further, assume that the expected return of the stock is \(\mathbb{E}(R_r)=10\%\) and its standard deviation is \(\sigma_r=20\%\). The question that needs to be answered for any individual investor is how much to invest in each of these assets.

The expected return (\(\mathbb{E}(R_p)\)) of this portfolio is calculated as follows:

\begin{equation*} 
\mathbb{E}(R_p) = \mathbb{E}(R_f)\cdot w_f + \mathbb{E}(R_r)\cdot (1- w_f) 
\end{equation*}
where \(w_f\) is the relative allocation to the risk-free asset.

The calculation of this portfolio risk is simple because the standard deviation of the Treasury bill is 0\%. Thus

\begin{equation*} 
\sigma_p = (1-w_f)\cdot \sigma_r 
\end{equation*}
In this simple example, if an investor invested 100\% into the risk-free asset (\(w_f=1\)), the expected return would be 3\% and the risk of the portfolio would be 0\%. Otherwise, investing 100\% into the stock (\(w_f=0\)) would give an investor an expected return of 10\% and a portfolio risk of 20\%. If the investor allocated 25\% to the risk-free asset and 75\% to the risky asset, the portfolio expected return and risk calculations would be

\begin{equation*}
\begin{gathered}
\mathbb{E}(R_p) = (3\% \cdot 25\%) + (10\% \cdot 75\%) = 0.75\% + 7.5\% = 8.25\% \\
\sigma_p = 75\% \cdot 20\% = 15\% 
\end{gathered}
\end{equation*}
\noindent
If you plot these three points they lay on a line.

If we added a risk-free asset, with an expected return of 10\%, to the five risky ones considered so far we could repeat the Markowitz minimisation to determine the efficient frontier of the resulting portfolio. 

\begin{ipython}
num_assets = 6
returns_rf = np.append(returns.values, 0.10)
cov_rf = np.column_stack((covariances.values, np.array([0, 0, 0, 0, 0])))
cov_rf = np.row_stack((cov_rf, np.array([0, 0, 0, 0, 0, 0])))
print (cov_rf)

result_rf = []

for t_ret in np.arange(0.1, 0.4, 0.01):
    weights = [1/n_assets for _ in range(num_assets)]
    bounds = [(0, 1) for _ in range(num_assets)]
    constraints = [{'type':'eq', 'fun':sum_weights},
                   {'type':'eq', 'fun':target_return, 'args':(returns_rf, t_ret)}]

    opts = minimize(min_risk, weights, bounds=bounds, 
                    constraints=constraints, args=(cov_rf))

    result_rf.append((np.sqrt(risk(opts.x, covariance)),
                      returns.dot(opts.x)))
\end{ipython}
\begin{ioutput}
[[0.05190222 0.02503721 0.02573699 0.02245413 0.02775968 0.        ]
 [0.02503721 0.08583929 0.04102487 0.03950122 0.04841167 0.        ]
 [0.02573699 0.04102487 0.06955025 0.03612685 0.04452847 0.        ]
 [0.02245413 0.03950122 0.03612685 0.05179662 0.04038995 0.        ]
 [0.02775968 0.04841167 0.04452847 0.04038995 0.17829826 0.        ]
 [0.         0.         0.         0.         0.         0.        ]]
\end{ioutput}

\begin{figure}[htb]
\centering
\includegraphics[width=0.7\textwidth]{figures/cal}
\caption{Comparison of efficient frontier with a risk-free asset (red) and with risky asset only (blue).}
\label{fig:cal}
\end{figure}
    
As expected the efficient frontier has become a straight line, tangent to the frontier of the risky assets (Fig.~\ref{fig:cal}). When the target is 10\% the entire investment is allocated to the risk-free asset, as the target increases the fraction of risky assets grows proportionally to the volatility. 

It is important to notice that in general the relative proportions among the risky investments do not change with or without the risk-free asset. Only the allocation between the risk-free and the risky parts varies.

\section{The Sharpe Ratio}
\label{the-sharpe-ratio}
The goal of an investor who is seeking to earn the highest possible expected return for any level of volatility is to find the portfolio that generates the steepest possible line when combined with the risk-free investment. This line slope is called the \emph{Sharpe ratio} of the portfolio.

For a portfolio of risky assets let be

\begin{itemize}
\tightlist
\item \(R_r\) its expected return;
\item \(\sigma_r\) its standard deviation in return;
\item \(r_f\) the return of a risk-free asset.
\end{itemize}

A plausible single measure of attractiveness of a portfolio (as opposed to the two measures, risk and return proposed by MPT model) is the Sharpe ratio:

\begin{equation} 
\mathcal{S} = \cfrac{R_r - r_f}{\sigma_r} 
\end{equation}
\noindent
In words, it measures how much additional return is achieved for the higher risk taken on, relative to investing all in the risk-free asset. 

The portfolio that maximizes this ratio has some interesting properties. Suppose that

\begin{itemize}
\tightlist
\item
  \(R_\textrm{target}\) the desired target return;
\item
  \(w_r\) the fraction of wealth placed in the portfolio (the rest placed in the risk-free asset).
\end{itemize}
\noindent
To meet the target return the weights need to be chosen such that:

\begin{equation*} 
(1 - w_r) * r_f + w_r * R_r =R_\textrm{target} 
\end{equation*}
\noindent
The standard deviation of the investment is: \(w_r\cdot \sigma_r\). Solving for \(w_r\) in the equation above, we get:

\begin{equation*} 
	w_r = \cfrac{R_\textrm{target} - r_f}{R_r - r_f} 
\end{equation*}
Thus, the standard deviation of the portfolio is:

\begin{equation*} 
w_r\cdot \sigma_r = \left(\cfrac{R_\textrm{target} - r_f}{R_r - r_f}\right)\cdot \sigma_r 
\end{equation*}
Minimizing the portfolio standard deviation means:

\begin{equation} 
\textrm{min}\left\{\cfrac{R_\textrm{target} - r_f}{R_r - r_f}\cdot \sigma_r\right\} = \textrm{min}\left[\cfrac{R_\textrm{target} - r_f}{\mathcal{S}}\right]
\end{equation}

Since in the above formula both $R_{\textrm{target}}$ and $r_f$ are constant, the minimization is equivalent to the maximization of the denominator of the expression, hence of the Sharpe ratio $\mathcal{S}$.

\begin{equation} 
\textrm{min}\left\{\cfrac{R_\textrm{target} - r_f}{\mathcal{S}}\right\}
\implies\textrm{max}\left\{\cfrac{R_r - r_f}{\sigma_r}\right\}
\end{equation}

So, regardless of investor risk/return preference, \emph{the investment should go in the portfolio that maximises the Sharpe ratio}, because it will be the one that minimize the risk (i.e. standard deviation) and maximise the return at the same time.

Let's compute the Sharpe portofolio with our sample.

\begin{ipython}
num_assets = 5
rf_asset_return = 0.10

def sharpe_ratio(w, returns, rf_asset_return, cov): 
    p_ret = returns.dot(w)
    p_var = np.sqrt(w.T.dot(cov.dot(w)))
    ratio = -(p_ret - rf_asset_return) / p_var
    return ratio

constraints = ({'type': 'eq', 'fun': sum_weights})
bounds = tuple((0, 1) for asset in range(num_assets))
weights = [1./num_assets for _ in range(num_assets)]
opts = minimize(sharpe_ratio, weights, args=(returns, rf_asset_return, covariance),
                bounds=bounds, constraints=constraints)
print (opts)
print ("Sharpe ratio: ", -opts.fun)
\end{ipython}
\begin{ioutput}
     fun: -1.259317843917775
     jac: array([-0.37875983, -0.37936528, -0.26915939,  0.02855796, -0.37932488])
 message: 'Optimization terminated successfully'
    nfev: 36
     nit: 6
    njev: 6
  status: 0
 success: True
       x: array([1.19754346e-01, 5.43974190e-01, 5.20417043e-18, 1.22298005e-16,
                 3.36271464e-01])

Sharpe ratio:  1.259317843917775)
\end{ioutput}

Figure~\ref{fig:sharpe_ratio} shows the optimization results. Notice that in general the relative proportions of the stocks are the same as in the previous case (at the same level of return) where we explicitly included a risk free asset (0.12, 0.54, 0., 0., 0.33).

\begin{figure}[htb]
\centering
\includegraphics[width=0.7\textwidth]{figures/sharpe_ratio}
\caption{Sharpe portfolio (green cross) compared to the efficient frontier with a risk-free asset (red) and with risky asset only (blue).}
\label{fig:sharpe_ratio}
\end{figure}

So using the Sharpe ratio gives a portfolio that is on the efficient frontier, and gives the maximum return relative to putting all our money in the risk-free asset so is on the CAL too. Graphically it sits in the only place that belongs to both curves: the tangent point.

Usually, any Sharpe ratio greater than 1.0 is considered acceptable to good by investors. A ratio higher than 2.0 is rated as very good. A ratio of 3.0 or higher is considered excellent. A ratio under 1.0 is sub-optimal.

\section{Portfolio Diversification}

A security total risk can be divided into \emph{unsystematic}, the risk portion peculiar to the company that can be diversified away, and systematic, the non-diversifiable portion that is related to the movement of the stock market and is therefore unavoidable. 

Diversification is a common topic in portfolio construction and allows to combine risky stocks so that the resulting portfolio is less risky than the sum of its components. Although such diversification is a familiar notion, it may be worthwhile to review the manner in which diversification reduces risk.

Suppose there are two companies located on an isolated island whose chief industry is tourism. One company manufactures suntan lotion; its stock predictably performs well in sunny years and poorly in rainy ones. The other company produces umbrellas; its stock performs equally poorly in sunny years and well in rainy ones. Each company earns a 12\% average return.

In purchasing either stock, investors incur a great amount of risk because of the price variability driven by fluctuations in weather conditions. Investing half the funds in the suntan lotion stock and half in the umbrella manufacturer stock, however, results in a return of 12\% regardless of which weather condition prevails. Portfolio diversification thus transforms two risky stocks, each with an average return of 12\%, into a riskless portfolio certain of earning the expected 12\%.

Unfortunately, the perfect negative relationship between the returns on these two stocks is very rare in real world. To some extent, corporate securities move together, so complete elimination of risk through simple portfolio diversification is impossible. However, as long as some lack of parallelism in the returns of securities exists, diversification will always reduce risk.
Empirical studies have demonstrated that risk can be virtually eliminated in portfolios of 30 to 40 randomly selected stocks. Of course, if investments are made in closely related industries, more securities are required to eradicate it.

When using the standard variation of the portfolio return as a measure of the risk, as in the Markowitz model, it is easy to show how diversification allows to reduce the risk. 
Indeed the standard deviation of a portfolio is not the weighted average of the standard deviations of the component stocks.
For example, suppose the correlation between the return of stocks 1 and 2 is $\rho_{12}$. If the portfolio is equally weighted then

\begin{equation}
\sigma_{P} = \sqrt{(0.5\cdot\sigma_1 )^2 + (0.5\cdot\sigma_2 )^2 + 2\cdot(0.5\cdot\sigma_1)(0.5\cdot\sigma_2)\rho_{12}} < (0.5\cdot\sigma_1 ) + (0.5\cdot\sigma_2 )
\end{equation}

The inequality holds unless $\rho_{12}=1$, so in general, for risk, the whole is less than the sum of its parts. 
This is the key to portfolio diversification.

Figure~\ref{fig:diversification} shows the risk of a portfolio made up of IBM and General Electric stocks against the fraction of GE stocks in the portfolio. The curved line represents the risk of the portfolio; the straight line is the sum of the two contributions. The risk of GE is 27.4\% per year, the risk of IBM is 29.7\% per year, and the two are 62.9\% correlated. The gap between the lines is an indication of the benefit of diversification in reducing risk.

\begin{figure}[htb]
\centering
\includegraphics[width=0.7\textwidth]{figures/diversification}
\caption{Risk of a portfolio made up from IBM and General Electric against the fraction of GE stock in the portfolio. The curved line represents the risk of the portfolio; the straight line represents the sum of the two single risks.}
\label{fig:diversification}
\end{figure}

%We can see the power of diversification in another example. Given a  portfolio of $N$ stocks, each with risk $\sigma$ and uncorrelated returns, the risk of an equal-weighted portfolio of these stocks will be
%\begin{equation}
%\sigma_P = \cfrac{\sigma}{\sqrt{N}}
%\end{equation}
%
%Assume now that the correlation between the returns of all pairs of stocks is equal to $\rho$. Then the risk of an equally weighted portfolio is:
%\begin{equation}
%\sigma_P = \sigma\cdot\sqrt{\cfrac{1+\rho(N-1)}{N}};\quad \lim_{N \to +\infty} \sigma_P = \sigma\cdot\sqrt{\rho}
%\label{eq:risk_correlation}
%\end{equation}
%which can be further simplified when considering a portfolio contains a very large number of correlated stocks
%
%To get a feel for this, consider the example of an equal-weighted portfolio of the 20 Major Market Index constituent stocks. In December 1992, these stocks had an average risk of 27.8\%, while the equal-weighted portfolio has a risk of 20.4\%. Equation~\ref{eq:risk_correlation} then implies an average correlation between these stocks of 0.52. 

%As we have already seen no measure of unsystematic risk appears in the risk premium, of CAPM model, since it is assumed that diversification has eliminated it.
%
%In the Markowitz model instead diversification is achieved by seeking to combine in a portfolio assets with returns that are less than perfectly positively correlated, in an effort to lower portfolio risk (variance) without sacrificing return, through the reduction of the correlation matrix $\Sigma$.

\section{Black-Litterman Portfolio}
\label{sec:black-litterman}
This example shows the workflow to implement the Black-Litterman model with the Portfolio class in Financial Toolbox™. The Black-Litterman model is an asset allocation approach that allows investment analysts to incorporate subjective views (based on investment analyst estimates) into market equilibrium returns. By blending analyst views and equilibrium returns instead of relying only on historical asset returns, the Black-Litterman model provides a systematic way to estimate the mean and covariance of asset returns.



In the Black-Litterman model, the blended expected return is 
−
μ
=[P
T
Ω
−1
P+C
−1
]
−1
[P
T
Ω
−1
q+C
−1
π] and the estimation uncertainty is cov(μ)=[P
T
Ω
−1
P+C
−1
]
−1
. To use the Black-Litterman model, you must prepare the inputs: P,q ,Ω , π, and C. The inputs for P, q , and Ω are view-related and defined by the investment analyst. π is the equilibrium return and C is the uncertainty in prior belief. This example guides you to define these inputs and use the resulting blended returns in a portfolio optimization. For more information on the concept and derivation of the Black-Litterman model, see the Appendix section Black-Litterman Model under a Bayesian Framework.

Define the Universe of Assets
The dowPortfolio.xlsx data set includes 30 assets and one benchmark. Seven assets from this data set comprise the investment universe in this example. The risk-free rate is assumed to be zero.

T = readtable('dowPortfolio.xlsx');
Define the asset universe and extract the asset returns from the price data.

assetNames = ["AA", "AIG", "WMT", "MSFT", "BA", "GE", "IBM"];
benchmarkName = "DJI";
head(T(:,["Dates" benchmarkName assetNames]))
Dates        DJI      AA       AIG      WMT     MSFT      BA       GE       IBM 
___________    _____    _____    _____    _____    _____    _____    _____    _____

03-Jan-2006    10847    28.72    68.41     44.9    26.19    68.63     33.6    80.13
04-Jan-2006    10880    28.89    68.51    44.99    26.32    69.34    33.56    80.03
05-Jan-2006    10882    29.12     68.6    44.38    26.34    68.53    33.47    80.56
06-Jan-2006    10959    29.02    68.89    44.56    26.26    67.57     33.7    82.96
09-Jan-2006    11012    29.37    68.57     44.4    26.21    67.01    33.61    81.76
10-Jan-2006    11012    28.44    69.18    44.54    26.35    67.33    33.43     82.1
11-Jan-2006    11043    28.05     69.6    45.23    26.63     68.3    33.66    82.19
12-Jan-2006    10962    27.68    69.04    44.43    26.48     67.9    33.25    81.61
retnsT = tick2ret(T(:, 2:end));
assetRetns = retnsT(:, assetNames);
benchRetn = retnsT(:, "DJI");
numAssets = size(assetRetns, 2);
Specify Views of the Market
The views represent the subjective views of the investment analyst regarding future market changes, expressed as q =P∗μ + ε,   ε~N(0, Ω), Ω=diag(ω
1
,ω
2
,...ω
v
), where v is total number of views. For more information, see the Appendix section Assumptions and Views. With v views and k assets, P is a v-by-k matrix, q is a v-by-1 vector, and Ω is a v-by-v diagonal matrix (representing the independent uncertainty in the views). The views do not necessarily need to be independent among themselves and the structure of Ω can be chosen to account for investment analyst uncertainties in the views [4]. The smaller the ω
i
in Ω, the smaller the variance in the distribution of the ith view, and the stronger or more certain the investor's ith view. This example assumes three independent views.

AIG is going to have 5% annual return with uncertainty 1e-3. This is a weak absolute view due to its high uncertainty.

WMT is going to have 3% annual return with uncertainty 1e-3. This is a weak absolute view due to its high uncertainty.

MSFT is going to outperform IBM by 5% annual return with uncertainty 1e-5. This is a strong relative view due to its low uncertainty.

v = 3;  % total 3 views
P = zeros(v, numAssets);
q = zeros(v, 1);
Omega = zeros(v);

% View 1
P(1, assetNames=="AIG") = 1; 
q(1) = 0.05;
Omega(1, 1) = 1e-3;

% View 2
P(2, assetNames=="WMT") = 1; 
q(2) = 0.03;
Omega(2, 2) = 1e-3;

% View 3
P(3, assetNames=="MSFT") = 1; 
P(3, assetNames=="IBM") = -1; 
q(3) = 0.05;
Omega(3, 3) = 1e-5;
Visualize the three views in table form.

viewTable = array2table([P q diag(Omega)], 'VariableNames', [assetNames "View_Return" "View_Uncertainty"]) 
viewTable=3×9 table
AA    AIG    WMT    MSFT    BA    GE    IBM    View_Return    View_Uncertainty
__    ___    ___    ____    __    __    ___    ___________    ________________

0      1      0      0      0     0      0        0.05             0.001      
0      0      1      0      0     0      0        0.03             0.001      
0      0      0      1      0     0     -1        0.05             1e-05      

Because the returns from dowPortfolio.xlsx data set are daily returns and the views are on the annual returns, you must convert views to be on daily returns.

bizyear2bizday = 1/252;
q = q*bizyear2bizday; 
Omega = Omega*bizyear2bizday;
Estimate the Covariance from the Historical Asset Returns
Σ is the covariance of the historical asset returns.

Sigma = cov(assetRetns.Variables);
Define the Uncertainty C
The Black-Litterman model makes the assumption that the structure of C is proportional to the covariance Σ. Therefore, C=τΣ, where τ is a small constant. A smaller τ indicates a higher confidence in the prior belief of μ. The work of He and Litterman uses a value of 0.025. Other authors suggest using 1/n where n is the number of data points used to generate the covariance matrix [3]. This example uses 1/n.

tau = 1/size(assetRetns.Variables, 1);
C = tau*Sigma;
Market Implied Equilibrium Return
In the absence of any views, the equilibrium returns are likely equal to the implied returns from the equilibrium portfolio holding. In practice, the applicable equilibrium portfolio holding can be any optimal portfolio that the investment analyst would use in the absence of additional views on the market, such as the portfolio benchmark, an index, or even the current portfolio [2]. In this example, you use linear regression to find a market portfolio that tracks the returns of the DJI benchmark. Then, you use the market portfolio as the equilibrium portfolio and the equilibrium returns are implied from the market portfolio. The findMarketPortfolioAndImpliedReturn function, defined in Local Functions, implements the equilibrium returns. This function takes historical asset returns and benchmark returns as inputs and outputs the market portfolio and the corresponding implied returns.

[wtsMarket, PI] = findMarketPortfolioAndImpliedReturn(assetRetns.Variables, benchRetn.Variables);
Compute the Estimated Mean Return and Covariance
Use the P, q , Ω , π , and C inputs to compute the blended asset return and variance using the Black-Litterman model.

You can compute 
−
μ
and cov(μ) directly by using this matrix operation:

−
μ
=[P
T
Ω
−1
P+C
−1
]
−1
[P
T
Ω
−1
q+C
−1
π], cov(μ)=[P
T
Ω
−1
P+C
−1
]
−1

mu_bl = (P'*(Omega\P) + inv(C)) \ ( C\PI + P'*(Omega\q));
cov_mu = inv(P'*(Omega\P) + inv(C));
Comparing the blended expected return from Black-Litterman model to the prior belief of expected return π, you find that the expected return from Black-Litterman model is indeed a mixture of both prior belief and investor views. For example, as shown in the table below, the prior belief assumes similar returns for MSFT and IBM, but in the blended expected return, MSFT has a higher return than IBM by more than 4%. This difference is due to the imposed strong view that MSFT outperforms IBM by 5%.

table(assetNames', PI*252, mu_bl*252, 'VariableNames', ["Asset_Name", ...
"Prior_Belief_of_Expected_Return", "Black_Litterman_Blended_Expected_Return"])
ans=7×3 table
Asset_Name    Prior_Belief_of_Expected_Return    Black_Litterman_Blended_Expected_Return
__________    _______________________________    _______________________________________

"AA"                    0.19143                                0.19012                
"AIG"                   0.14432                                0.13303                
"WMT"                   0.15754                                 0.1408                
"MSFT"                  0.14071                                0.17557                
"BA"                    0.21108                                 0.2017                
"GE"                    0.13323                                0.12525                
"IBM"                   0.14816                                0.12877                

Portfolio Optimization and Results
The Portfolio object in Financial Toolbox™ implements the Markowitz mean variance portfolio optimization framework. Using a Portfolio object, you can find the efficient portfolio for a given risk or return level, and you can also maximize the Sharpe ratio.

Use estimateMaxSharpeRatio with the Portfolio object to find allocations with the maximum Sharpe ratio for the following portfolios:

Portfolio with asset mean and covariance from historical asset returns

Portfolio with blended asset return and covariance from the Black-Litterman model

port = Portfolio('NumAssets', numAssets, 'lb', 0, 'budget', 1, 'Name', 'Mean Variance');
port = setAssetMoments(port, mean(assetRetns.Variables), Sigma);
wts = estimateMaxSharpeRatio(port);

portBL = Portfolio('NumAssets', numAssets, 'lb', 0, 'budget', 1, 'Name', 'Mean Variance with Black-Litterman');
portBL = setAssetMoments(portBL, mu_bl, Sigma + cov_mu);  
wtsBL = estimateMaxSharpeRatio(portBL);

ax1 = subplot(1,2,1);
idx = wts>0.001;
pie(ax1, wts(idx), assetNames(idx));
title(ax1, port.Name ,'Position', [-0.05, 1.6, 0]);

ax2 = subplot(1,2,2);
idx_BL = wtsBL>0.001;
pie(ax2, wtsBL(idx_BL), assetNames(idx_BL));
title(ax2, portBL.Name ,'Position', [-0.05, 1.6, 0]);


table(assetNames', wts, wtsBL, 'VariableNames', ["AssetName", "Mean_Variance", ...
"Mean_Variance_with_Black_Litterman"])
ans=7×3 table
AssetName    Mean_Variance    Mean_Variance_with_Black_Litterman
_________    _____________    __________________________________

"AA"         6.5494e-11                     0.1115             
"AIG"        6.6964e-12                    0.23314             
"WMT"        2.6063e-12                   0.098048             
"MSFT"         0.059393                    0.15824             
"BA"            0.32068                    0.10748             
"GE"         7.3366e-10                     0.1772             
"IBM"           0.61993                    0.11439             

When you use the values for the blended asset return and the covariance from the Black-Litterman model in a mean-variance optimization, the optimal allocations reflect the views of the investment analyst directly. The allocation from the Black-Litterman model is more diversified, as the pie chart shows. Also, the weights among the assets in the Black-Litterman model agree with the investment analyst views. For example, when you compare the Black-Litterman result with the plain mean-variance optimization result, you can see that the Black-Litterman result is more heavily invested in MSFT than in IBM. This is because the investment analyst has a strong view that MSFT will outperform IBM.

Local Functions
function [wtsMarket, PI] = findMarketPortfolioAndImpliedReturn(assetRetn, benchRetn)
% Find the market portfolio that tracks the benchmark and its corresponding implied expected return.
The implied return is calculated by reverse optimization. The risk-free rate is assumed to be zero. The general formulation of a portfolio optimization is given by the Markowitz optimization problem: 
argmax
ω
ω
T
μ−
δ
2
ω
T
Σω. Here ω is an N-element vector of asset weights, μ is an N-element vector of expected asset returns, Σ is the N-by-N covariance matrix of asset returns, and δ is a positive risk aversion parameter. Given δ , in the absence of constraints, a closed form solution to this problem is ω=
1
δ
Σ
−1
μ. Therefore, with a market portfolio, the implied expected return is π=δΣω
mkt
.

To compute an implied expected return, you need Σ,ω
mkt
,δ.

1) Find Σ.

Σ is calculated from historical asset returns.

Sigma = cov(assetRetn);
2) Find the market portfolio.

To find the market portfolio, regress against the DJI. The imposed constraints are fully invested and long only: 
n
∑
i=1
ω
i
=1,0≤ω
i
,∀i∈{1,...,n}

numAssets = size(assetRetn,2);
LB = zeros(1,numAssets);
Aeq = ones(1,numAssets);
Beq = 1;
opts = optimoptions('lsqlin','Algorithm','interior-point', 'Display',"off");
wtsMarket = lsqlin(assetRetn, benchRetn, [], [], Aeq, Beq, LB, [], [], opts);
3) Find δ.

Multiply both sides of π=δΣω
mkt
with ω
T
mkt
to output δ=
SharpeRatio
σ
m
. Here, the Benchmark is assumed to be maximizing the Sharpe ratio and the corresponding value is used as market Sharpe ratio. Alternatively, you can calibrate an annualized Sharpe ratio to be 0.5, which leads to shpr=0.5/sqrt(252) [1]. σ
m
is the standard deviation of the market portfolio.

shpr = mean(benchRetn)/std(benchRetn);
delta = shpr/sqrt(wtsMarket'*Sigma*wtsMarket); 
4) Compute the implied expected return.

Assuming that the market portfolio maximizes the Sharpe ratio, the implied return, without the effects from constraints, is computed directly as π=δΣω.

PI = delta*Sigma*wtsMarket;
end
Appendix: Black-Litterman Model Under a Bayesian Framework
Assumptions and Views
Assume that the investment universe is composed of k assets and the vector of asset returns r is modeled as a random variable, following a multivariate normal distribution r~N(μ,Σ). Σ is the covariance from historical asset returns. The unknown model parameter is the expected return μ. From the perspective of Bayesian statistics, the Black-Litterman model attempts to estimate μ by combining the investment analyst views (or "observations of the future") and some prior knowledge about μ.

In addition, assume the prior knowledge that μ is a normally distributed random variable μ~N(π,C) [1, 2]. In the absence of any views (observations), the prior mean π is likely to be the equilibrium returns, implied from the equilibrium portfolio holding. In practice, the applicable equilibrium portfolio holding is not necessarily the equilibrium portfolio, but rather a target optimal portfolio that the investment analyst would use in the absence of additional views on the market, such as the portfolio benchmark, an index, or even the current portfolio. C represents the uncertainty in the prior and the Black-Litterman model makes the assumption that the structure of C is τΣ. τ is a small constant, and many authors use different values. A detailed discussion about τ can be found in [3].

Observations are necessary to perform a statistical inference on μ. In the Black-Litterman model, the observations are views about future asset returns expressed at the portfolio level. A view is the expected return of a portfolio composed of the universe of k assets. Usually, the portfolio return has uncertainty, so an error term is added to catch the departure. Assume that there is a total of v views. For a view i, p
i
is a row vector with dimension 1 x k, and q
i
is a scalar [2].

q
i
= Ε[p
i
∗r ∣ μ]+ε
i 
,  i=1,2,...,v

You can stack the v views vertically, and Ω is the covariance of the uncertainties from all views. Assume that the uncertainties are independent.

q = Ε[P∗r ∣ μ]+ ε,  ε~N(0, Ω),  Ω=diag(ω
1
,ω
2
,...ω
v
).

Note that Ω does not necessarily need to be a diagonal matrix. The investment analyst can choose the structure of Ω to account for their uncertainties in the views [4].

Under the previous assumption r~N(μ,Σ), it follows that

q =P∗μ + ε,   ε~N(0, Ω), Ω=diag(ω
1
,ω
2
,...ω
v
).

The Bayesian Definition of the Black-Litterman Model
Based on Bayesian statistics, it is known that: posterior∝likelihood∗prior.



In the context of the Black-Litterman model, posterior∝likelihood∗prior is expressed as f(μ∣q)∝ f(q∣μ)*f(μ), where each Bayesian term is defined as follows [2]:

The likelihood is how likely it is for the views to happen given μ and is expressed as f(q∣μ)∝exp[−
1
2
(Pμ−q)
′
Ω
−1
(Pμ−q)].

The prior assumes the prior knowledge that μ~N(π,C) and is expressed as f(μ)   ∝exp[−
1
2
(μ−π)
′
C
−1
(μ−π)].

The posterior is the distribution of μ given views and is expressed as f(μ∣q) ∝exp[−
1
2
(Pμ−q)
′
Ω
−1
(Pμ−q)−
1
2
(μ−π)
′
C
−1
(μ−π)].

As previously stated, the posterior distribution of μ is also a normal distribution. By completing the squares, you can derive the posterior mean and covariance as 
−
μ
=[P
T
Ω
−1
P+C
−1
]
−1
[P
T
Ω
−1
q+C
−1
π], cov(μ)=[P
T
Ω
−1
P+C
−1
]
−1
.

Finally, by combining the Bayesian posterior distribution of μ and the model of asset returns r~N(μ,Σ), you then have the posterior prediction of asset returns as r~N(
−
μ
, Σ+cov(μ)).



\section{Risk Parity Portfolio}
\label{risk-parity-portfolio}

An alternative approach to optimize a portfolio is given by the \emph{risk parity}. A risk parity portfolio is an investment allocation strategy which focuses on the allocation of risk, rather than on the allocation of capital. 
Such a portfolio is characterised by having equal risk contributions to the total risk from each individual asset. 

This allocation strategy has gained popularity in the last decades since it is believed to provide better risk adjusted return than capital based allocation strategies.

Risk parity allocation is also referred to as equally-weighted risk contributions portfolio method. Equally-weighted risk contributions is not about \emph{having the same volatility}, it is about having each asset contributing in the same way to the portfolio overall volatility. For this we will have to define the contribution of each asset to the portfolio risk. 

Let's go over a very basic example to better illustrate how to construct a simple risk parity portfolio. Consider a portfolio of \(N\) assets: \(x_{1}, \ldots, x_N\) where as usual the weight of the $i^{th}$ asset is denoted by \(w_{i}\) and all the \(w_{i}\) form the allocation vector \(\mathbf{w}\). Let us further denote the covariance matrix of the assets as \(\Sigma\). The volatility of the portfolio is then defined as:

\begin{equation} 
\sigma_p={\sqrt {\mathbf{w}^T\Sigma \mathbf{w}}} = \sum_{i=1}^{N}\sigma _{i}\qquad\textrm{with}~\sigma _{i} = w_{i}\cdot \cfrac{\partial\sigma_p}{\partial w_{i}}={\cfrac {w_{i}(\Sigma \mathbf{w})_{i}}{\sqrt {\mathbf{w}^T\Sigma \mathbf{w}}}}
\end{equation}
so that \(\sigma _{i}\) can be interpreted as the contribution of the $i^{th}$ asset to the overall risk of the portfolio.

\begin{attention}
\subsubsection{Derivation of $\sigma_i$}
Expressing explicitly in matrix form the standard deviation of the portfolio we get
\[
\begin{split}
\sigma_p={\sqrt {\mathbf{w}^T\Sigma \mathbf{w}}} & =
\sqrt{
	\begin{bmatrix}
	w_{1} \\
	w_{2}
	\end{bmatrix}
	\begin{bmatrix}
	\sigma_{11} & \sigma_{21} \\
	\sigma_{12} & \sigma_{22} 
	\end{bmatrix}
	\begin{bmatrix}
	w_{1} & w_{2} \\
	\end{bmatrix}
}\\
&=
\sqrt{
	\begin{bmatrix}
	w_{1} \\
	w_{2}
	\end{bmatrix}
	\begin{bmatrix}
w_{1}\sigma_{11} + w_{2}\sigma_{12} & w_{1}\sigma_{21} + w_{2}\sigma_{22} \\
	\end{bmatrix}
} \\
&= \sqrt{
w_{1}w_{1}\sigma_{11} + w_{2}w_{1}\sigma_{12} + w_{1}w_{2}\sigma_{21} + w_{2}w_{2}\sigma_{22} }
\end{split}
\]
Now performing the derivative with respect to $w_1$ we obtain
\[\cfrac{\partial\sigma_p}{\partial w_1} = \cfrac{1}{2}\cdot\cfrac{2\cdot w_1\sigma_{11} + 2\cdot w_{2}\sigma_{21}}{\sigma_p} = \cfrac{w_1\sigma_{11} + w_{2}\sigma_{21}}{\sigma_p} = \cfrac{(\Sigma \mathbf{w})_{1}}{\sigma_p}\]
	
Summing up $\sum_{i=1}^{N} w_i\cdot\cfrac{\partial\sigma_p}{\partial w_i}$ we get back $\sigma_p$
\end{attention}

Equal risk contribution then means \(\sigma _{i} =\sigma _{j}\) for all \(i,j\) or equivalently \(\sigma _{i}=\sigma_p/N\). So

\begin{equation}
\sigma _{i} = \cfrac{\sigma_p}{N}={\cfrac {w_{i}(\Sigma \mathbf{w})_{i}}{\sqrt {\mathbf{w}^T\Sigma \mathbf{w}}}}\implies w_{i} = \frac {\sigma_p^{2}}{(\Sigma \mathbf{w})_{i}N}
\label{eq:risk_parity_weights}
\end{equation}
Since we want the previous expression to be true for each $i$, the solution for the weights can be found by solving the minimisation problem

\begin{equation} 
\underset{\mathbf{w}}{\min } \sum _{i=1}^{N}\left[w_{i}-{\frac {\sigma_p^{2}}{(\Sigma \mathbf{w})_{i}N}}\right]^{2} 
\end{equation}
\noindent
where ideally it is required to be 0 the difference between the squared sum of the weights and the theoretical values expressed by Eq~\ref{eq:risk_parity_weights}.

Going back to our data sample let's find out the weights to give us a risk parity portfolio.

\begin{ipython}
num_assets = 5
def risk_parity(w, cov):
    variance = w.T.dot(cov.dot(w))
    *@sum@* = 0
    N = len(w)
    for i in range(N):
        *@sum@* += (w[i] - (variance/(N*cov.dot(w)[i])))**2
    return *@sum@*
	
args = (covariance,)
constraints = ({'type': 'eq', 'fun': sum_weights})
bounds = tuple((0, 1) for asset in range(num_assets))
weights = [1./num_assets for _ in range(num_assets)]
opts = minimize(risk_parity, weights, args=(covariance,),
                bounds=bounds, constraints=constraints)
print (opts)
\end{ipython}
\begin{ioutput}
    fun: 2.2881862766486147e-07
    jac: array([-6.98851511e-04,  1.92391042e-04, -4.08403758e-05, 
                -2.54432521e-05,  1.13250609e-03])
message: 'Optimization terminated successfully.'
   nfev: 38
    nit: 5
   njev: 5
 status: 0
success: True
x: array([0.25863039, 0.18154282, 0.19666705, 0.22190633, 
          0.14125342])
\end{ioutput}

\begin{ipython}
sigma_i = []
std = np.sqrt(opts.x.T.dot(covariance.dot(opts.x)))
for i in range(num_assets):
    a = opts.x[i]*covariance.dot(opts.x)[i]
	sigma_i.append(a/std)
	
for i in range(num_assets):
    print ("Risk contribution for asset {}: {:.3f}%".format(i, sigma_i[i]
                                                            /sum(sigma_i)*100))
\end{ipython}
\begin{ioutput}
Risk contribution for asset 0: 19.974%
Risk contribution for asset 1: 19.999%
Risk contribution for asset 2: 19.990%
Risk contribution for asset 3: 19.992%
Risk contribution for asset 4: 20.045%
\end{ioutput}

Figure~\ref{fig:risk_parity} shows the fraction of risk allocated to each asset with the corresponding weight within the portfolio.

\begin{figure}[htb]
\centering
\includegraphics[width=0.7\textwidth]{figures/risk_parity}
\caption{Fraction of risk allocated among the assets of a portfolio. The blue numbers show the corresponding weight of each asset.}
\label{fig:risk_parity}
\end{figure}

\subsection{Risk Budget Allocation}
\label{risk-budget-allocation}

The same technique can be used if we would like to calculate a portfolio with risk budget allocation. In this case we want to associate to each asset a particular level of risk.We can now change the previous equation which was setting every asset risk contribution fraction to $1/N$

\begin{equation} 
\sigma _{i}=\cfrac{\sigma_p}{N} 
\end{equation}
and replace it with the desired fraction of risk (\(f_i\)) specific for each asset

\begin{equation} 
\sigma _{i}=f_i \cdot \sigma_p 
\end{equation}
so that the relation to minimise becomes

\begin{equation} 
\underset{\mathbf{w}}{\min} \sum _{i=1}^{N}\left[w_{i}-{\frac {f_i \cdot \sigma_p^{2}}{(\Sigma \mathbf{w})_{i}}}\right]^{2} 
\end{equation}
\noindent
Translating it into \texttt{python} we get:
\begin{ipython}
def risk_budget(w, target_risk, cov):
    variance = w.T.dot(cov.dot(w))
    *@sum@* = 0
    N = len(w)
    for i in range(N):
        *@sum@* += (w[i] - (target_risk[i]*variance)/(cov.dot(w)[i]))**2
    return *@sum@*
	
f_i = [0.3, 0.2, 0.2, 0.15, 0.15]
args = (f_i, covariance)
constraints = ({'type': 'eq', 'fun': sum_weights})
bounds = tuple((0, 1) for asset in range(num_assets))
weights = [1./num_assets for _ in range(num_assets)]
opts = minimize(risk_budget, weights, args=(f_i, covariance),
                bounds=bounds, constraints=constraints)
print (opts)
\end{ipython}
\begin{ioutput}
    fun: 4.058673684147486e-08
    jac: array([-2.64817707e-04,  3.30937403e-04,  2.14530647e-05, 
                -7.65372775e-05,  3.67853561e-04])
message: 'Optimization terminated successfully.'
   nfev: 45
    nit: 6
   njev: 6
 status: 0
success: True
      x: array([0.3459366 , 0.1800917 , 0.19394454, 0.16890483, 
                0.11112233])
\end{ioutput}
\begin{ipython}  
sigma_i = []
std = np.sqrt(opts.x.T.dot(covariance.dot(opts.x)))
for i in range(num_assets):
    a = opts.x[i]*covariance.dot(opts.x)[i]
    sigma_i.append(a/std)
	
for i in range(num_assets):
    print ("Risk contribution for asset {}: {:.3f}%".format(i, sigma_i[i]
                                                            /sum(sigma_i)*100))    
\end{ipython}
\begin{ioutput}
Risk contribution for asset 0: 29.988%
Risk contribution for asset 1: 20.010%
Risk contribution for asset 2: 19.996%
Risk contribution for asset 3: 14.993%
Risk contribution for asset 4: 15.012%
\end{ioutput}

Figure~\ref{fig:risk_allocation} shows the amount of risk associated to each asset and its weight within the portfolio. 
Indeed for each stock we have allocated the desired amount of risk.

\begin{figure}[htb]
\centering
\includegraphics[width=0.7\textwidth]{figures/risk_allocation}
\caption{Fraction of risk allocated among the assets of a portfolio. The blue numbers show the corresponding weight of each asset.}
\label{fig:risk_allocation}
\end{figure}

%\subsection{Maximum Diversification Portfolio}
%\label{maximum-diversification-portfolio}
%
%Diversification is most often either pursued in tandem with other objective, such as return maximization, or pursued simply by including more asset classes or adding constraints based on intuition.
%
%But it does not have to be this way and diversification can be pursued explicitly as the sole objective in portfolio construction.
%In a 2008 paper~\cite{bib:diversification}, the diversification ratio $D$ of a portfolio has been defined as
%
%\begin{equation}
%D=\cfrac{\mathbf{w}^T\boldsymbol{\sigma}}{\sqrt {\mathbf{w}^T\Sigma \mathbf{w}}} 
%\end{equation}
%where $\boldsymbol{\sigma}$ is the vector of volatilities and $\Sigma$ is the covariance matrix. The denominator represents portfolio volatility and the numerator the asset weighted average volatilities. More diversification within a portfolio decreases the denominator and leads to a higher diversification ratio.
%Let's construct a portfolio that maximize this ratio.
%
%\begin{ipython}
%def diversification_ratio(w):
%    w_vol = np.dot(np.sqrt(np.diag(covariance)), w.T)
%    port_vol = np.sqrt(np.dot(w.T, np.dot(covariance, w)))
%    diversification_ratio = w_vol/port_vol
%    return -diversification_ratio
%	
%bounds = tuple((0, 1) for asset in range(num_assets))
%cons = ({'type': 'eq', 'fun': sum_weights},)
%#cons = cons + ({'type': 'ineq', 'fun': long_only_constraint},)
%weights = [1./num_assets for _ in range(num_assets)]
%opts = minimize(diversification_ratio, weights, bounds=bounds,
%                constraints=cons)
%print (opts)
%\end{ipython}
%\begin{ioutput}
%    fun: -1.3580745811820554
%    jac: array([-0.00035974,  0.00029349, -0.00035594,  0.00077944,  
%                 0.00016446])
%message: 'Optimization terminated successfully.'
%   nfev: 36
%    nit: 5
%   njev: 5
% status: 0
%success: True
%      x: array([0.34867985, 0.18062199, 0.15557008, 0.1235694, 0.19155868])
%\end{ioutput}
%\begin{ipython}
%ret = np.sum(returns*opts.x)
%vol = np.sqrt(opts.x.T.dot(np.dot(covariance, opts.x))) 
%print ("Return: ", ret)
%print ("Vol: ", vol)
%print ("Diversification: ", -opts.fun)
%\end{ipython}
%\begin{ioutput}
%Return:  0.32143376694380044
%Vol:  0.20743461253140413
%Diversification:  1.360393553158368
%\end{ioutput}
%
%Figure~\ref{fig:max_div} shows how the maximum diversified portfolio compares to the efficient frontier.
%
%\begin{figure}[htb]
%\centering
%\includegraphics[width=0.7\textwidth]{figures/max_div}
%\caption{Portfolio constructed with the maximum diversification technique shown in the return/variance plane.}
%\label{fig:max_div}
%\end{figure}


\section{PCA1 Portfolio}
\label{portfolio-optimization-and-pca}

In Section~\ref{sec:pca} the Principal Component Analysis (PCA) has been introduced and here we are going to apply PCA on equity return covariance matrix to construct principal component portfolios because they have some interesting characteristics. This means that the portfolio weights will be based on the eigenvectors of the covariance matrix.

From the theory we know that the first principal component (PC1) is a factor that captures the maximal amount of variance (i.e. the linear combination of assets that has highest possible variance). The second principal component factor (PC2) is the second most variable portfolio that is orthogonal to the first and so on.

From the discussion of the CAPM model in Section~\ref{sec:capm} we learnt that the market factor ($\beta$) is the primary driver of the stock market returns, as it tends to explain most of the returns of any given stock in any given day.
So it is expected that applying PCA to daily stock returns, the first principal component approximates the market risk premium from the CAPM model.

In this analysis we are going to use the equities forming the \emph{Dow Jones 30} index, so the first step is to download their returns with \texttt{yfinance} package (the data availability is from March 2019 to today).
	
\begin{ipython}
import yfinance as yf
tickers = ["BA","CAT","CVX","CSCO","KO",
           "DOW","XOM","GS","HD","INTC","IBM",
           "JNJ","JPM","MCD","MRK","MSFT","NKE",
           "PFE","PG","RTX","TRV","UNH","VZ",
           "V","WBA", "WMT", "^DJI"]

proxy = yf.Tickers(tickers)           
df = proxy.history(start='2014-03-27',
                   end='2021-03-31')['Close'].pct_change().dropna()
\end{ipython}
	
Since the package returns already daily returns we can directly compute the covariance matrix from them. Also we determine eigenvalues and eigenvectors of this matrix.

\begin{ipython}
import numpy as np

equities = df.iloc[:, :-1]
cov = equities.cov()
eigVals, eigVecs = np.linalg.eig(cov)
indices = [i for i in reversed(np.argsort(eigVals))]
l = [eigVals[i]/np.*@sum@*(eigVals)*100 for i in reversed(np.argsort(eigVals))]
\end{ipython}
	
Looking at the explained variance plot (see Fig.~\ref{fig:explained_variance}) we can notice how the first principal component explains almost 60\% then the value falls quickly down.

\begin{figure}[htb]
	\centering
	\includegraphics[width=.7\textwidth]{figures/portfolio_pca_expl_var}
	\caption{Explained variance plot. Notice how the explained variance decreases steeply after the first component, and also how the returned components are not ordered by eigenvalue.}
	\label{fig:explained_variance}
\end{figure}
		
Next we can re-scale the PC's eigenvectors to sum up to 1 so they can be used as portfolio weights.
	
\begin{ipython}
norm_eigVecs = [v/np.linalg.norm(v) for v in eigVecs.T]
\end{ipython}
	
Finally we can construct a portfolio using the weights derived from PCs. In other words each asset takes a weight equal to its corresponding component in the PC eigenvector. Figure~\ref{fig:pca_weights} reports the weights of each asset in PC1 (the first principal component).
	
\begin{figure}[htb]
	\centering
	\includegraphics[width=.7\textwidth]{figures/portfolio_pca_pc1_weights}
	\caption{Weights of the PC1 portfolio. Each asset is weighed according to the corresponding component in the first principal component eigenvector.}
	\label{fig:pca_weights}
\end{figure}
	
Then we calculate the cumulative return of the portfolio and compare it to the market return. This process is repeated for the first three components.

\begin{ipython}
for i, index in enumerate(indices[0:3]):
    pc_daily_ret = equities.dot(norm_eigVecs[index])
    pc_cum_ret = pc_daily_ret.cumsum()
    market_cum_ret = df['^DJI'].cumsum()
\end{ipython}
	
From Fig.~\ref{fig:ret_pc1} to~\ref{fig:ret_pc3} it is clear how the PC1 portfolio return looks identical to the market. The second and third PC portfolio returns look quite different instead. It is not easy to interpret them though. 

\begin{figure}[htbp]
	\centering
		\subfloat[Cumulative return of PC1 (left) compared to the market return (right).\label{fig:ret_pc1}]{%
		\includegraphics[width=0.7\textwidth]{figures/cum_ret_pc1_vs_market}
	}\\
	\subfloat[Cumulative return of PC2 (left) compared to the market return (right).
	\label{fig:ret_pc2}]{%
		\includegraphics[width=0.7\textwidth]{figures/cum_ret_pc2_vs_market}
	}\\
	\subfloat[Cumulative return of PC3 (left) compared to the market return (right). 
	\label{fig:ret_pc3}]{%
		\includegraphics[width=0.7\textwidth]{figures/cum_ret_pc3_vs_market}
	}
	\caption{Comparison of cumulative return of various principle components portfolios to the market return.}
    \label{fig:dummy2}
\end{figure}

It can be verified that PC1 portfolio still looks like the market also for other time horizon, repeating the same steps using weekly or monthly data.

\section*{Exercises}
\input{portfolio_ex_text}

\begin{thebibliography}{9}
\bibitem{bib:post_modern_theory}\href{https://en.wikipedia.org/wiki/Post-modern_portfolio_theory}{\emph{Post Modern Theory}}, Wikipedia [Online]
\bibitem{bib:black_litterman}\href{https://en.wikipedia.org/wiki/Black\%E2\%80\%93Litterman_model}{\emph{Black-Litterman Model}}, Wikipedia [Online]
\bibitem{bib:diversification} Y. Choueifaty, Y.Coignard, \href{ https://www.tobam.fr/wp-content/uploads/2014/12/TOBAM-JoPM-Maximum-Div-2008.pdf}{\emph{Toward Maximum Diversification}}, 2008
\end{thebibliography}
