\begin{question}
A Treasury bond has a coupon of 9\%, a face value of 1000 USD and matures 10 years from today. For a treasury bond the interest on the bond is paid in semi-annual installments. The current risk-less interest rate is 12\% (compounded semi-annually).
\begin{enumerate}
\item Suppose you purchase the Treasury bond described above and immediately thereafter the risk-less interest rate falls to 8\%. (compounded semi-annually). What would be the new market price of the bond?
\item What is your best estimate of what the price would be if the risk-less interest rate was 9\% (compounded semi-annually) ?
\end{enumerate}
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
import numpy as np

N = 1000
maturity = 10
coupon = 0.09
tenor = 0.5
rates = {i:0.08 for i in range(1, int((maturity/tenor)+1))}

price = 0
for tau in range(1, int((maturity/tenor)+1)):
    price += N * coupon*tenor / (1+rates[tau]*tenor)**(tau)
price += N / (1+rates[tau]*tenor)**(tau) 

print ("{:.2f} USD".format(price))
\end{ipython}
\begin{ioutput}
1067.95 USD
\end{ioutput}

\begin{ipython}
rates = {i:0.09 for i in range(1, int((maturity/tenor)+1))}
	
price = 0
for tau in range(1, int((maturity/tenor)+1)):
    price += N * coupon*tenor / (1+rates[tau]*tenor)**(tau)
price += N / (1+rates[tau]*tenor)**(tau) 
	
print ("{:.2f} USD".format(price))
\end{ipython}
\begin{ioutput}
1000.00 USD
\end{ioutput}
\end{solution}

\begin{question}
A 100 USD, 10 year bond was issued 7 years ago at a 10\% annual interest rate. The current interest rate is 9\%.The current price of the bond is 100.917 USD. Use annual, discrete compounding. Calculate the bonds yield to maturity.
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
from scipy.optimize import brentq

def ytom(y, N, C, P0, maturity_years, tenor=1): 
    price = 0
    for p in range(1, int((maturity_years/tenor)+1)):
        price += C*tenor*N/(1+y*tenor)**p
    price += N/(1+y*tenor)**p - P0 
    return price

y = brentq(ytom, -0.3, 1, args=(100, 0.10, 100.917, 3, 1))
print ("yield to maturity: {:3f}".format(y))
\end{ipython}
\begin{ioutput}
yield to maturity: 0.096
\end{ioutput}    
\end{solution}

\begin{question}
Suppose you are trying to determine the interest rate sensitivity of two bonds. Bond 1 is a 12\% coupon bond with a 7-year maturity and a 1000 USD principal. Bond 2 is a ‘zero-coupon’ bond that pays 1120 USD after 7 year.The current interest rate is 12\%.
\begin{enumerate}
\item Determine the duration of each bond.
\item If the interest rate increases 100 basis points (100 basis points = 1\%), what will be the capital loss on each bond ?
\end{enumerate}
\end{question}

\cprotEnv\begin{solution}
The first part of the exercise can be solved by applying the definition of duration.
\begin{ipython}
def zero_bond_pv(N, r, maturity):
    return N / (1+r)**(maturity)

def zero_mac_duration(P0, maturity): 
    return maturity * P0/P0 

def bond_pv(N, C, r, maturity, tenor=1):
    price = 0
    for tau in range(1, int((maturity/tenor)+1)):
        price += N * C*tenor / (1+r*tenor)**(tau)
    price += N / (1+r*tenor)**(tau)
    return price

def mac_duration(N, C, y, maturity, tenor=1): 
    P0 = bond_pv(N, C, y, maturity, tenor)
    d=0
    for tau in range(1, int((maturity/tenor)+1)):
        d += tau*N*C*tenor/(1+y*tenor)**tau/P0
    d += tau*N/(1+y*tenor)**tau/P0 
    return P0, d

P0, dur = mac_duration(1000, 0.12, 0.12, 7)
print ("Bond price: {:.2f}".format(P0))
print ("Duration: {:.2f}".format(dur))

PZ = zero_bond_pv(1120, 0.12, 7) 
print ("Zero Bond price: {:.2f} USD".format(PZ))
durZ = zero_mac_duration(PZ, 7)
print ("Zero Duration: {:.2f}".format(durZ))
\end{ipython}
\begin{ioutput}
Bond price: 1000.00
Duration: 5.11
Zero Bond price: 506.63
Zero Duration: 7.00
\end{ioutput}

For the second part the exact capital losses can be obtained by re-computing the bond prices with the new rate.

\begin{ipython}
P1 = bond_pv(1000, 0.12, 0.13, 7)
print ("Bond price: {:.2f} USD".format(P1))
print ("Capital loss Bond: {:.3f}%".format(100*(P1-P0)/P0))

PZ1 = zero_bond_pv(1120, 0.13, 7) 
print ("Bond price: {:.2f} USD".format(PZ1))
print ("Capital loss Zero Bond: {:.3f}%".format(100*(PZ1-PZ)/PZ))
\end{ipython}
\begin{ioutput}
Bond price: 955.77 USD
Capital loss Bond: -4.423%
Bond price: 476.07 USD
Capital loss Zero Bond: -6.033%
\end{ioutput}

An approximate solution instead can be estimated by applying the relation $\Delta P/P = -D\Delta r$.
\begin{ipython}
closs1 = -dur*0.01
print ("Capital loss1: {:.3f}%".format(closs1*100))

closs2 = -durZ*0.01
print ("Capital loss1: {:.3f}%".format(closs2*100))
\end{ipython}
\begin{ioutput}
Capital loss1: -5.111%
Capital loss1: -7.000%
\end{ioutput}
\end{solution}

%\begin{question}
%From the \texttt{OvernightIndexSwap} created in the previous example derive a discount curve using the bootstrap method.
%\end{question}
%
%\cprotEnv\begin{solution}
%We have just created some swaps from the market quotes in the previous exercise, so now we can just create a list with the pillar dates.
%
%\begin{ipython}
%observation_date = date(2019, 10, 23)
%pillar_dates = [observation_date]
%
%for swap in swaps:
%    pillar_dates.append(swap.payment_dates[-1])
%
%# this shouldn't be necessary if the original
%# list of market quotes is sorted
%pillar_dates = sorted(pillar_dates)
%\end{ipython}
%Define the objective function: the sum of the squared NPVs of the OIS.
%\begin{ipython}
%def objective_function(x):
%    curve = DiscountCurve(observation_date,
%        pillar_dates, x)
%
%    sum_sq = 0.0
%    for swap in swaps:
%        sum_sq += swap.npv(curve) ** 2
%    return sum_sq
%\end{ipython}
%Set the initial value of the discount factors (\(x_i\)) to 1 with a range of variability \([ 0.01, 10]\), in addition the first element of the list, today's discount factor, will be fixed to 1 (variability \([1, 1]\)).
%
%\begin{ipython}
%x0 = [1.0 for i in range(len(pillar_dates))]
%
%bounds = [(0.01, 10.0) for i in range(len(pillar_dates))]
%bounds[0] = (1.0, 1.0)
%\end{ipython}
%Finally launch the minimizer to find the discount factors (\(\mathbf{x}\)).
%
%\begin{ipython}
%from scipy.optimize import minimize
%
%result = minimize(objective_function, x0, bounds=bounds)
%print (result)
%\end{ipython}
%\begin{ioutput}
%     fun: 0.000819919032900304
%hess_inv: <34x34 LbfgsInvHessProduct with dtype=float64>
%     jac: array([ 6.58948735e+05, -1.58720803e+01, -6.53143264e+01, 
%                 -1.03323232e+02, -1.26050260e+02, -1.31748898e+02, 
%                 -1.20374599e+02, -9.15399651e+01, -4.24363322e+01,  
%                  2.44903182e+01,  1.14345243e+02,  2.22002243e+02,
%                 -3.72021700e+00,  4.21398633e+01,  4.21787852e+01,  
%                  4.22369487e+01,  4.23327026e+01,  4.31814758e+01,  
%                  4.44924460e+01,  4.62078978e+01,  4.82906823e+01, 
%                  -3.69972738e+00,-1.42454702e+00,  7.53771932e-01,
%                  2.79741018e+00,  4.62896699e+00,  6.24844054e+00,  
%                  9.93101553e+00,  1.31122434e+01,  1.42880909e+01,  
%                  1.48279215e+01,  1.50787019e+01,  1.43267935e+01,  
%                  1.38451324e+01])
% message: b'CONVERGENCE: REL\_REDUCTION\_OF\_F\_<=\_FACTR*EPSMCH'
%    nfev: 840
%     nit: 7
%  status: 0
% success: True
%       x: array([1.        , 1.00030147, 1.00058831, 1.00089012, 1.00119726,
%                 1.00147996, 1.00178743, 1.00208107, 1.00238467, 1.00267865,
%                 1.00298261, 1.00327737, 1.00357104, 1.00357104, 1.00355063,
%                 1.00352002, 1.00346901, 1.00302007, 1.00232627, 1.00141821,
%                 1.00031629, 0.99911234, 0.99790839, 0.99675545, 0.99567393,
%                 0.99470465, 0.9938476 , 0.99189884, 0.99021534, 0.98959296,
%                 0.98930728, 0.98917464, 0.98957256, 0.98982763])
%\end{ioutput}
%\end{solution}
%
%\begin{question}
%Consider the bearing coupon bonds listed in the next Table. Using the pseudo-inverse method determine discount factors and yields (assume continuous compounding).
%
%\begin{table}[htb]
%	\begin{center}
%		\begin{tabular}{|c|c|c|}
%			\hline
%			\textbf{price} & \textbf{maturity} & \textbf{coupon} \\
%			\hline
%			\euro{96.60} & 1 & 2.0\% \\
%			\hline
%			\euro{93.71} & 2 & 2.5\% \\
%			\hline
%			\euro{91.56} & 3 & 3.0\% \\
%			\hline
%			\euro{90.24} & 4 & 3.5\% \\
%			\hline
%			\euro{89.74} & 5 & 4.0\% \\
%			\hline
%			\euro{90.04} & 6 & 4.5\% \\
%			\hline
%			\euro{91.09} & 7 & 5.0\% \\
%			\hline
% 			\euro{92.82} & 8 & 5.5\% \\
%			\hline
%			\euro{95.19} & 9 & 6.0\% \\
%			\hline
%			\euro{98.14} & 10 & 6.5\% \\
%			\hline
%		\end{tabular}
%	\end{center}
%\end{table}
%	
%\end{question}
%
%\cprotEnv\begin{solution}
%\begin{ipython}
%import numpy as np
%
%C = np.array([[102, 0, 0, 0, 0, 0, 0, 0, 0, 0],
%              [2.5, 102.5, 0, 0, 0, 0, 0, 0, 0, 0],
%              [3, 3, 103, 0, 0, 0, 0, 0, 0, 0],
%              [3.5, 3.5, 3.5, 103.5, 0, 0, 0, 0, 0, 0],
%              [4, 4, 4, 4, 104, 0, 0, 0, 0, 0],
%              [4.5, 4.5, 4.5, 4.5, 4.5, 104.5, 0, 0, 0, 0],
%              [5, 5, 5, 5, 5, 5, 105, 0, 0, 0],
%              [5.5, 5.5, 5.5, 5.5, 5.5, 5.5, 5.5, 105.5, 0, 0],
%              [6, 6, 6, 6, 6, 6, 6, 6, 106, 0],
%              [6.5, 6.5, 6.5, 6.5, 6.5, 6.5, 6.5, 6.5, 6.5, 106.5]])
%
%P = np.array([96.60, 93.71, 91.56, 90.24, 89.74, 
%              90.04, 91.09, 92.82, 95.19, 98.14])
%
%Cinv = np.linalg.pinv(C)
%d = Cinv.dot(P.T)
%print (d)
%\end{ipython}
%\begin{ioutput}
%[0.94705882 0.89114491 0.83539212 0.7814726  0.72999737 0.68140865
% 0.63578693 0.59296268 0.55300618 0.51574181]
%\end{ioutput}
%
%\begin{ipython}
%from math import log
%
%for i in range(10):
%    print ("yield y{}: {:.3f}%".format(i+1, -log(d[i])/(i+1)*100))
%\end{ipython}
%\begin{ioutput}
%yield y1: 5.439%
%yield y2: 5.762%
%yield y3: 5.995%
%yield y4: 6.164%
%yield y5: 6.294%
%yield y6: 6.393%
%yield y7: 6.470%
%yield y8: 6.533%
%yield y9: 6.582%
%yield y10: 6.621%
%\end{ioutput}
%\end{solution}
