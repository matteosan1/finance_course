\chapter{Numerical Python}
\label{ch:numerical_python}

\texttt{numpy} (Numerical Python)~\cite{bib:numpy} module is a sort of \texttt{python} language extension thought to optimze big data management.
The module introduces multi-dimensional arrays and a lot of useful functions like linear algebra, FFT, random numbers\ldots

The most striking feature of \texttt{numpy} is that functions and methods act directly on arrays allowing to avoid explicit loops which usually are not very efficient. Also most of the \texttt{numpy} code is written in \texttt{C} which significantly boosts its performance. 

\section{\texttt{array} Datatype}

\texttt{numpy} defines a new data type which acts as an N-dimensional array. Its \emph{size} defines the number of elements, the \emph{rank} is the number of axis (or dimensions), the \emph{shape} it's a \texttt{tuple} with the number of elements in each dimension, the \emph{itemsize} represents the memory size of each item.

\begin{ipythonnon}
import numpy as np

a = np.array([[1, 2], [2, 2]])
print (a.shape)

b = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print (b.shape)
\end{ipythonnon}
\begin{ioutput}
(2, 2)
(2, 2, 2)
\end{ioutput}

The simplest way to create an array is by converting already existing structures like lists or tuples

\begin{ipythonnon}
import numpy as np
 
a = np.array([1, 2, 3, 4])
lista = [1, 2, 3, 4]
tupla = (5, 6, 7, 8)
a = np.array(lista)
b = np.array(tupla)
c = np.array([lista, tupla])
\end{ipythonnon}

If the array content is not known a priori, it is convenient to use helper functions to systematically fill it:
\begin{itemize}
\item \texttt{numpy.zeros}: creates an array with specified shape and fill it with zeros;
\item \texttt{numpy.ones}: same as zeros but fills with ones;
\item \texttt{numpy.empty}: creates an array with given shape without initialization;
\item \texttt{numpy.identity}: returns the $n\times n$ identity matrix;
\item \texttt{numpy.eye}: creates an $n\times m$ matrix filling with ones the $k-th$ diagonal.
\end{itemize}

Similarly to \texttt{range} for the standard lists, \texttt{numpy.arange} allows to create an array filled with a sequence of numbers (not necessarily integers). Alternatively, \texttt{numpy.linspace} makes a sequence evenly spaced between the two specified limits.

\subsection{Reshape and Resize}

The \texttt{numpy.resize} and \texttt{numpy.reshape} methods allow to modify the shape and size of an array. 
The first one works in-place and modify the size of the array (missing items are filled with zeros), the latter returns a new array re-distributing the original items according to the new shape.

\begin{ipythonnon}
a = np.arange(20)
a.resize(5, 6)
print (f"a:\n{a}")

a = np.array(range(1, 9))
print (f"shape: {a.shape}")
\end{ipythonnon}
\begin{ioutput}
shape (8,)
\end{ioutput}

\section{Indexing, Slicing, Iterating}

Items of an array can be accessed through the \texttt{[]} operator. It is also possible to use the slicing operator \texttt{[:]} which works similarly to lists.

\begin{ipythonnon}
a = np.ones(4)
print ("a[0] ", a[0])
print (a [1:3])

a = np.array([[1, 2, 3], [4, 5, 6],[7, 8, 9],[10, 11, 12]])
print (a[0][0])
print(a[2])
print (a[:, 1])
print (a[2:, 1:3])

a = np.arange(25)
a = a.reshape((5, 5))
print (a[1])
print (a[1, :])
print (a[1, ::2])
print (a[1, 5::-1])
\end{ipythonnon}
\begin{ioutput}
a[0]  1.0
[1. 1.]
1
[7 8 9]
[ 2  5  8 11]
[[ 8  9]
 [11 12]]
[5 6 7 8 9]
[5 6 7 8 9]
[5 7 9]
[9 8 7 6 5]
\end{ioutput}

Note that, although the notationn is the same, slicing in array is deeply different from that for lists.
In arrays the "sub-array" points directly to the same memory area of the original array, so if it is modified the same happens to the original array. In lists the "sub-list" is a distinct new list which is \emph{disconnected} to the original .

To explicitly create a new copy of an array it can be used the \texttt{copy} method.

\subsection{Fancy Indexing}

Item selection can be done using more complicated techniques, in particular
\begin{itemize}
\item using an array of indices;
\item with a boolean mask.
\end{itemize}

\begin{ipythonnon}
x = np.arange(10, 1, -1)
print (f"x:\n{x}")

A = x[np.array([3, 3, 2, 8])]
print (f"x[np.array([3, 3, 2, 8])]:\n{A}")

AA = x[np.array([[3, 3], [2, 8]])]
print (f"x[np.array([[3, 3], [2, 8]])]:\n{AA}")

y = np.array([[ 0, 1, 2, 3, 4, 5],
              [ 6, 7, 8, 9, 10, 11],
              [12, 13, 14, 15, 16, 17]])
print (f"y:\n{y}")
y[y>10]
print (f"y[y>10]:\n{y[y>10]}")

a = np.array([10, 3, 8, 0, 19, 10, 11, 9, 10, 6])
print (f"a: {a}")
a[a % 3 == 0] = -2
print (f"a[a % 3 == 0] = -2: {a}")
\end{ipythonnon}
\begin{ioutput}
x:
[10  9  8  7  6  5  4  3  2]
x[np.array([3, 3, 2, 8])]:
[7 7 8 2]
x[np.array([[3, 3], [2, 8]])]:
[[7 7]
 [8 2]]
y:
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]]
y[y>10]:
[11 12 13 14 15 16 17]
a: [10  3  8  0 19 10 11  9 10  6]
a[a % 3 == 0] = -2: [10 -2  8 -2 19 10 11 -2 10 -2]
\end{ioutput}

Iterations through the items can be done in various ways:
\begin{itemize}
\item using a standard for-loop. A single for-cycle is applied by default on the first axis.
\begin{ipythonnon}
a = np.arange(9).reshape(3,3)

for i in range(a.shape[0]):
  for j in range(a.shape[1]):
    a[i, j] = i + j

print (f"a:\n{a}")
\end{ipythonnon}
\item Using the \texttt{flat} iterator on each item of the array
\begin{ipythonnon}
for i in a.flat():
  print (i)
\end{ipythonnon}
\begin{ioutput}
a:
[[0 1 2]
 [1 2 3]
 [2 3 4]]
\end{ioutput}
\end{itemize}
In general those are not computationally efficient techniques. It is much better to exploit the dedicated \texttt{C} functions provided by the module which works directly on the whole axis at once.

\section{Working with arrays}
\label{sec:vectorialization}

Most of the \texttt{numpy} functionalities are based on a technique called \emph{vectorialization}. This means that all the operators work automatically element-wise on the entire array without the usage of explicit loops. Also the module defines special functions called \emph{ufunc} (universal functions) which operate in same manner. Note that functions based on the same technique are defined also in other modules like \texttt{scipy.stats}.

\subsubsection{Operations with Scalars}
\begin{ipythonnon}
a = np.array([1, 2, 3, 4])
print (a + 1) # sum with a scalar
print (a - 2) # subtraction with a scalar
print (3 * a) # multipication with a scalar
print (2**a)  # power (scalar base)
print (a / 2) # division by a scalar
\end{ipythonnon}
\begin{ioutput}
[2 3 4 5]
[-1  0  1  2]
[ 3  6  9 12]
[ 2  4  8 16]
[0.5 1.  1.5 2. ]
\end{ioutput}

\subsubsection{Arithmetical Operators}

\begin{ipythonnon}
a = np.array([1, 2, 3, 4])
b = np.ones(4) + 1
print (a - b)         # subtraction between arrays
print (a * b)         # multipication between arrays
a += 1                # autoincrement
print (a)
print (2**(a+1) - a)  # expression with array
\end{ipythonnon}
\begin{ioutput}
[-1.  0.  1.  2.]
[2. 4. 6. 8.]
[2 3 4 5]
[ 6 13 28 59]
\end{ioutput}

\subsubsection{ufunc}

\begin{ipythonnon}
a = np.arange(1, 5)
print (f"a: {a}")
b = np.cos(a)
print (f"np.cos(a): {b}")

b = np.log(a)
print (f"np.log(a): {b}")

b = np.exp(a)
print (f"np.exp(a): {b}")

a = np.array([2, 0, 3, 5])
print (f"a: {a}")
b = np.array([1, 1, 1, 6])
print (f"b: {b}")
c = np.maximum(a, b)
print (f"np.maximum(a, b): {c}")
\end{ipythonnon}
\begin{ioutput}
a: [1 2 3 4]
np.cos(a): [ 0.54030231 -0.41614684 -0.9899925  -0.65364362]
np.log(a): [0.         0.69314718 1.09861229 1.38629436]
np.exp(a): [ 2.71828183  7.3890561  20.08553692 54.59815003]
a: [2 0 3 5]
b: [1 1 1 6]
np.maximum(a, b): [2 1 3 6]
\end{ioutput}

\subsubsection{Comparison Operators}
If instead an array-wise comparison is needed you must use \texttt{numpy.array\_equal}.

\begin{ipythonnon}
a = np.array([1, 2, 3, 4])
b = np.array([4, 2, 2, 4])

print (f"a==b: {a == b}")
print (f"a>b: {a > b}")

c = np.array([1, 2, 3, 4])
print (f"np.array_equal(a, b): {np.array_equal(a, b)}")
print (f"np.array_equal(a, c): {np.array_equal(a, c)}")
\end{ipythonnon}
\begin{ioutput}
a==b: [False  True False  True]
a>b: [False False  True False]
np.array_equal(a, b): False
np.array_equal(a, c): True
\end{ioutput}

\subsection{Broadcasting}

Given that all the operators acting on arrays work element-wise, the operands used in the expressions must have the same shape.

\begin{ipythonnon}
a = np.arange(4)
a + np.array([1, 2])
\end{ipythonnon}
\begin{ioutput}
ValueError                                
Traceback (most recent call last)in <cell line: 2>()
      1 a = np.arange(4)
----> 2 a + np.array([1,2])

ValueError: operands could not be broadcast together with shapes (4,) (2,)
\end{ioutput}

Nevertheless sometimes it is possible to operate with different shaped arrays, this methodology is called \emph{broadcasting}. It follows two simple rules:
\begin{itemize}
\item the smaller array is resized according to the bigger one and filled with ones;
\item arrays with dimension 1 behave like the biggest in that dimension. The value is repeated along the broadcast direction.
\end{itemize}

\begin{ipythonnon}
a = np.array([1, 2, 3])
print (f"a: {a}")
b = np.array([[1, 2, 3], [4, 5, 6]])
print (f"b:\n{b}")
c = a + b # OK!! Broadcastable
print (f"c:\n{c}")
 
a = np.arange(30).reshape((2, 5, 3))
print (f"a: {a}")
b = np.arange(8).reshape((2, 4, 1)) 
print (f"b:\n{b}")
c = a + b # No Broadcastable
print (f"c:\n{c}")
\end{ipythonnon}
\begin{ioutput}
a: [1 2 3]
b:
[[1 2 3]
 [4 5 6]]
c:
[[2 4 6]
 [5 7 9]]
 
a: [[[ 0  1  2]
     [ 3  4  5]
     [ 6  7  8]
     [ 9 10 11]
     [12 13 14]]

    [[15 16 17]
     [18 19 20]
     [21 22 23]
     [24 25 26]
     [27 28 29]]]
b:
[[[0]
  [1]
  [2]
  [3]]

 [[4]
  [5]
  [6]
  [7]]]

ValueError
Traceback (most recent call last) in <cell line: 12>()
     10 b = np.arange(8).reshape((2, 4, 1))
     11 print (f"b:\n{b}")
---> 12 c = a + b # No Broadcastable
     13 print (f"c:\n{c}")

ValueError: operands could not be broadcast together with shapes (2,5,3) (2,4,1) 
\end{ioutput}

\section{Array Performance Examples}

\subsubsection{Dynamic Resizing}
Every time an array is resized a new copy of the original array is created with an additional element at the end. When the size of the array is big this becomes a very expensive operation.

That's why, when possible, it is much more efficient to start from a fixed size array and modfify each item by accessing it for example with the \texttt{[]} operator.

\begin{ipythonnon}
import time, numpy as np

t0 = time.time()
a = np.zeros(1)
for i in range(100000):
  a = np.insert(a, -1, i)
print (f"insert: {time.time()-t0:.3f} s")

t0 = time.time()
a = np.zeros(100000)
for i in range(100000):
  a[i] = i
print (f"pre-allocated: {time.time()-t0:.3f} s")
\end{ipythonnon}
\begin{ioutput}
insert: 3.773 s
pre-allocated: 0.019 s
\end{ioutput}

\subsubsection{For-loops}

\begin{ipythonnon}
import numpy as np, time

def for_array(a):
  for i in range(a.shape[0]):
    for j in range(a.shape[1]):
      a[i, j] = 3*a[i, j] + 1

def no_loop(a):
  a = a*3 + 1

a = np.ones(shape=(1000, 1000))
t0 = time.time()
for_array(a)
print (f"loop: {time.time()-t0:.3f} s")

a = np.ones(shape=(1000, 1000))
t0 = time.time()
no_loop(a)
print (f"no loop: {time.time()-t0:.3f} s")
\end{ipythonnon}
\begin{ioutput}
loop: 0.464 s
no loop: 0.034 s
\end{ioutput}

\subsubsection{Vectorized vs Scalar}

\begin{ipythonnon}
import numpy as np, time

a = np.arange(0, 4*np.pi, 0.001) 

t0 = time.time()
y = np.sin(a)*2 
print (f"vectorized: {time.time()-t0:.4f} s")

t0 = time.time()
y = np.zeros(len(a))
for i in range(len(a)):
  y[i] = np.sin(a[i])*2
print (f"scalar: {time.time()-t0:.4f} s")
\end{ipythonnon}
\begin{ioutput}
vectorized: 0.0007 s
scalar: 0.0208 s
\end{ioutput}
Unfortunately it is not always straightforward to vectorialize an expression.

\begin{ipythonnon}
import numpy as np

def func(x):
  if x<0: 
    return 1
  else: 
    return np.sin(x)

func(np.array([1,-2,9]))
\end{ipythonnon}
\begin{ioutput}
ValueError                      
Traceback (most recent call last) 
in <cell line: 8>()
      6 
      7 func(3)
----> 8 func(np.array([1,-2,9]))

in func(x)
      1 def func(x):
----> 2   if x<0:
      3     return 1
      4   else:
      5     return np.sin(x)

ValueError: The truth value of an array with more than one element is
ambiguous. Use a.any() or a.all()
\end{ioutput}

A first working fix is provided below, but it is rather slow since makes explicit usage of a for-loop. Also it works only with 1-d arrays.

\begin{ipythonnon}
import numpy as np

def func_NumPy(x):
  r = np.copy(x) # allocate result array
  for i in range(np.size(x)):
    if x[i] < 0:
      r[i] = 0.0
    else:
      r[i] = np.sin(x[i])
  return r

print (func_NumPy(np.array([1., -2., 9.])))
print (func_NumPy(np.array([[1, -2, 9], [1, -2, 9]])))
\end{ipythonnon}
\begin{ioutput}
[0.84147098 0.         0.41211849]

ValueError                          
Traceback (most recent call last)
 in <cell line: 11>()
      9 
     10 print (func_NumPy(np.array([1., -2., 9.])))
---> 11 print (func_NumPy(np.array([[1, -2, 9], [1, -2, 9]])))

in func_NumPy(x)
      2   r = np.copy(x) # allocate result array
      3   for i in range(np.size(x)):
----> 4     if x[i] < 0:
      5       r[i] = 0.0
      6     else:

ValueError: The truth value of an array with more than one element is
ambiguous. Use a.any() or a.all()
\end{ioutput}

A second fix uses the \texttt{numpy.where} function and make it completely general (avoid for-loops and works with multidimensional arrays).

\begin{ipythonnon}
import numpy as np

def func_NumPyV2(x):
  return np.where(x < 0, 0.0, np.sin(x))

func_NumPyV2(np.array([[1,-2,9], [1,-2,9]]))
\end{ipythonnon}
\begin{ioutput}
array([[0.84147098, 0.        , 0.41211849],
       [0.84147098, 0.        , 0.41211849]])
\end{ioutput}

\subsubsection{Slicing}
Slicing is often used to vectorialize operations. Consider for example an iterative procedure (e.g. finite difference method) where 
$$
\cfrac{\partial x}{\partial t} = \cfrac{x_{i+1} + 2\cdot x_i + x_{i-1}}{dt}
$$
this could be implented either with a for-loop (lines 3-7) or just with slicing (lines 9-10). 

\begin{ipython}
import numpy as np

n = 10
x = np.arange(0, 10)
dx = np.zeros(n)
for i in range(1, len(x)-1):
  dx[i] = x[i-1]+2*x[i]+x[i+1]

dx_vec = np.zeros(n)
dx_vec[1:n-1] = x[0:n-2] + 2*x[1:n-1] + x[2:n]
\end{ipython}

\subsection{Reduction}

All the reduction operators (e.g. \texttt{mean}, \texttt{std}, \texttt{median}, \texttt{max}, \texttt{min}) work similarly to the \texttt{sum} example shown below.

\begin{ipythonnon}
import numpy as np

x = np.array([[1, 1], [2, 2]])

print (x.sum(axis=0)) # sum by column
print (x.sum(axis=1)) # sum by row
print (x.sum())       # sum entire array
\end{ipythonnon}
\begin{ioutput}
[3 3]
[2 4]
6
\end{ioutput}