\begin{question}
Consider two 5\% coupon paying bonds (par value of 100 EUR) with the clean market prices of 99.50 EUR and 98.30 EUR and having maturities of 6 months and 1 year respectively.
Determine the spot rate for 6-month and 1-year.  
\end{question}

\cprotEnv\begin{solution}
At the end of 6 months the first bond will pay a coupon of 2.5 EUR (= 100 EUR * 5\%/ 2) plus the principal amount (= 100 EUR) which sums up to 102.50 EUR. To determine the 6M spot rate we can write the following equation,

\begin{ipython}
S_6m = 2*(102.5/99.5 - 1) 
print (S_6m)
\end{ipython}
\begin{ioutput}
0.06030150753768826
\end{ioutput}

\begin{equation*}
\cfrac{102.5}{(1 + S_{6M}/2)} = 99.5\qquad\Rightarrow\qquad S_{6M} = 2 \cdot \Big( \cfrac{102.5}{99.5} - 1 \Big) =  6.03 \%
\end{equation*}

At the end of another 6 months the second bond will pay a coupon of 2.5 EUR (= 100 EUR * 5\% / 2) plus the principal amount (= 100 EUR) which sums up to 102.50 EUR. The bond is traded at 98.30 EUR, therefore, the 1-year spot rate $S_{1y}$ can be calculated using $S_{6M}$ as,

\begin{equation*}
\cfrac{2.5}{(1+S_{6M}/2)} + \cfrac{102.5}{(1 + S_{1y}/2)^{2}} = 98.30
\end{equation*}

\begin{equation*}
\cfrac{102.5}{(1 + S_{1y}/2)^{2}} = 98.30 - \cfrac{2.5}{(1+0.03015)}
\end{equation*}

\begin{equation*}
(2 + S_{1y})^{2} = \cfrac{4\cdot102.5}{98.87317} = 4.276428
\end{equation*}

\begin{equation*}
S_{1y}^{2} + 4\cdot S_{1y} - 0.276428 = 0
\end{equation*}

\begin{ipython}
import numpy as np
coeff = [1, 4, -0.276428]
np.roots(coeff)
\end{ipython}
\begin{ioutput}
array([-4.06795261,  0.06795261])
\end{ioutput}

\begin{equation*}
S_{1y} = -2 \pm \sqrt{4 + 0.276428} =\begin{cases}\text{\sout{-4.06795}} \\ 6.80\%\end{cases}
\end{equation*}
\end{solution}

\begin{question}
A small petroleum company owns two refineries. Refinery 1 costs 20000 USD per day to operate, and it can produce 400 barrels of high-grade oil, 300 barrels of medium-grade oil, and 200 barrels of low-grade oil each day. Refinery 2 is newer and more modern. It costs 25000 USD per day to operate, and it can produce 300 barrels of high-grade oil, 400 barrels of medium-grade oil, and 500 barrels of low-grade oil each day.
The company has orders totaling 25000 barrels of high-grade oil, 27000 barrels of medium-grade oil, and 30000 barrels of low-grade oil. How many days should it run each refinery to minimize its costs and still refine enough oil to meet its orders?

\noindent\textbf{Hint:} you need to identify the unknown quantities (working days for each refinery) and set the constraints on the production of barrels. The objective is to minimize the costs. If you have multiple constraints you can define a list of dictionaries (one for constraint). Furthermore in this case the constraint is not \emph{equal to} but rather \emph{greater than} so you have to set \texttt{ineq} type.
\end{question}

\cprotEnv\begin{solution}
Let's implement the usual steps for a minimization. In this case our unknown are \texttt{x[0]} and \texttt{x[1]} the working days for each refinery. Then define the objective function with the production costs and three more functions, one for each oil-grade for the constraints.

\begin{ipython}
from scipy.optimize import minimize

def of(x):
    return 20000*x[0] + 25000*x[1]

def cons1(x):
    return 400*x[0] + 300*x[1] - 25000

def cons2(x):
    return 300*x[0] + 400*x[1] - 27000

def cons3(x):
    return 200*x[0] + 500*x[1] - 30000

cons = [{"type":"ineq", "fun":cons1},
        {"type":"ineq", "fun":cons2},
        {"type":"ineq", "fun":cons3}]
\end{ipython}
Set limits and initial values and run the minimizer.
\begin{ipython}
x0 = [10, 10]
bounds = [(0, 100) for _ in range(len(x0))]
r = minimize(of, x0, bounds=bounds, constraints=cons)
print (r)
\end{ipython}
\begin{ioutput}
     fun: 1750002.070622686
     jac: array([20000., 25000.])
 message: 'Optimization terminated successfully.'
    nfev: 8
     nit: 6
    njev: 2
  status: 0
 success: True
       x: array([25.00004033, 50.00005056])
\end{ioutput}    
So refinery 1 should work 25 days while refinery 2 50 days to minimize the production costs to 1.75 M USD (see objective function value in the minimization report).
\end{solution}

\begin{question}
Read the OIS market data from \href{https://raw.githubusercontent.com/matteosan1/finance_course/master/input_files/ois_quotes.csv}{\texttt{ois\_quotes.csv}} and construct the corresponding swaps.
\end{question}

\cprotEnv\begin{solution}

\begin{ipython}
obs_date = date.today()
df = pd.read_csv('ois_quotes.csv')
swaps = []

for i in range(len(df)):
    swap = OvernightIndexSwap(1e6, obs_date,
                              f"{df.iloc[i]['maturity']:.0f}m",
                              df.iloc[i]['rate'])
    swaps.append(swap)
\end{ipython}
\end{solution}

\begin{question}
From the \texttt{OvernightIndexSwap} created in the previous example derive a discount curve using the bootstrap method.
\end{question}

\cprotEnv\begin{solution}
We have just created some swaps from the market quotes in the previous exercise, so now we can just create a list with the pillar dates.
Set the initial value of the discount factors ($x_i$) to 1 with a range of variability $[ 0.01, 10]$, in addition the first element of the list, today's discount factor, will be fixed to 1 (variability $[1, 1]$).
Finally launch the minimizer to find the discount factors ($\mathbf{x}$).


\begin{ipython}
obs_date = date.today()
pillar_dates = []
for swap in swaps:
    pillar_dates.append(swap.payment_dates[-1])
    pillar_dates = sorted(pillar_dates)

def objective_function(x, obs_date, pillar_dates):
    curve = DiscountCurve(obs_date, pillar_dates, x)
    sum_sq = 0.0
    for swap in swaps:
        sum_sq += swap.npv(curve)**2
    return sum_sq

x0 = [1.0 for i in range(len(pillar_dates))]
bounds = [(0.01, 10.0) for i in range(len(pillar_dates))]
bounds[0] = (1.0, 1.0)

result = minimize(objective_function, x0, bounds=bounds,
                  args=(obs_date, pillar_dates))
print (result)
\end{ipython}
\begin{ioutput}
      fun: 8331.633347139361
 hess_inv: None
      jac: array([        nan, -1.69020495, -1.75787135, -1.8173523 , -1.870103  ,
       -1.91303115, -1.94595485, -1.97032931, -1.98488123, -1.98579072,
       -1.9725121 , -7.53570926,  2.40634107,  2.07692209,  1.87283148,
       -2.06928234,  3.4475306 ,  7.70742186,  6.94308252,  3.00806276,
       -0.71722752, -2.09674907, -0.76743163,  2.65299603,  6.86359268,
        9.26702337, 13.24679026, -4.50745572, -4.37703418, -6.18147169])
  message: 'CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH'
     nfev: 300
      nit: 8
     njev: 10
   status: 0
  success: True
        x: array([1.        , 0.9998132 , 0.99971258, 0.99961015, 0.99950111,
       0.999392  , 0.99928207, 0.99916369, 0.99903027, 0.998895  ,
       0.99874906, 0.99860278, 0.99807755, 0.99748218, 0.99674117,
       0.99582871, 0.9895829 , 0.97817149, 0.96223341, 0.94242757,
       0.9199792 , 0.89555418, 0.86968308, 0.84279963, 0.81599921,
       0.78928685, 0.71347125, 0.61195638, 0.53249028, 0.46683191])
\end{ioutput}

\end{solution}

\begin{question}
Consider the bearing coupon bonds listed in the next Table. Using the pseudo-inverse method determine discount factors and yields (assume continuous compounding).

\begin{table}[htb]
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			\textbf{price} & \textbf{maturity} & \textbf{coupon} \\
			\hline
			96.60 EUR & 1 & 2.0\% \\
			\hline
			93.71 EUR & 2 & 2.5\% \\
			\hline
			91.56 EUR & 3 & 3.0\% \\
			\hline
			90.24 EUR & 4 & 3.5\% \\
			\hline
			89.74 EUR & 5 & 4.0\% \\
			\hline
			90.04 EUR & 6 & 4.5\% \\
			\hline
			91.09 EUR & 7 & 5.0\% \\
			\hline
 			92.82 EUR & 8 & 5.5\% \\
			\hline
			95.19 EUR & 9 & 6.0\% \\
			\hline
			98.14 EUR & 10 & 6.5\% \\
			\hline
		\end{tabular}
	\end{center}
\end{table}
	
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
import numpy as np

C = np.array([[102, 0, 0, 0, 0, 0, 0, 0, 0, 0],
              [2.5, 102.5, 0, 0, 0, 0, 0, 0, 0, 0],
              [3, 3, 103, 0, 0, 0, 0, 0, 0, 0],
              [3.5, 3.5, 3.5, 103.5, 0, 0, 0, 0, 0, 0],
              [4, 4, 4, 4, 104, 0, 0, 0, 0, 0],
              [4.5, 4.5, 4.5, 4.5, 4.5, 104.5, 0, 0, 0, 0],
              [5, 5, 5, 5, 5, 5, 105, 0, 0, 0],
              [5.5, 5.5, 5.5, 5.5, 5.5, 5.5, 5.5, 105.5, 0, 0],
              [6, 6, 6, 6, 6, 6, 6, 6, 106, 0],
              [6.5, 6.5, 6.5, 6.5, 6.5, 6.5, 6.5, 6.5, 6.5, 106.5]])

P = np.array([96.60, 93.71, 91.56, 90.24, 89.74, 
              90.04, 91.09, 92.82, 95.19, 98.14])

Cinv = np.linalg.pinv(C)
d = Cinv.dot(P.T)
print (d)
\end{ipython}
\begin{ioutput}
[0.94705882 0.89114491 0.83539212 0.7814726  0.72999737 0.68140865
 0.63578693 0.59296268 0.55300618 0.51574181]
\end{ioutput}

\begin{ipython}
import numpy as np

for i in range(10):
    print (f"y{i+1}: {-np.log(d[i])/(i+1)*100:.3f}%")
\end{ipython}
\begin{ioutput}
y1: 5.439%
y2: 5.762%
y3: 5.995%
y4: 6.164%
y5: 6.294%
y6: 6.393%
y7: 6.470%
y8: 6.533%
y9: 6.582%
y10: 6.621%
\end{ioutput}
\end{solution}
