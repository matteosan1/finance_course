\cprotEnv\begin{question}
Take the code for the Black-Scholes formula from exercise~\ref{ex:BS1} and wrap it in a function. Then, use this function to calculate the prices of calls with various strikes, using the following input data.

\begin{ipython}
s = 800 
# strikes expressed as % of spot price
moneyness = [0.5, 0.75, 0.825, 1.0, 1.125, 1.25, 1.5]
vol = 0.3
ttm = 0.75
r = 0.005
\end{ipython}

The output should be a dictionary mapping strikes to call prices.
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
from math import log, exp, sqrt
from scipy.stats import norm

def d1(St, K, r, vol, ttm):
    num = log(St/K) + (r + 0.5*pow(vol, 2)) * ttm
    den = vol * sqrt(ttm)
    return num/den

def d2(St, K, r, vol, ttm):
    return d1(St, K, r, vol, ttm) - vol*sqrt(ttm)

def call(St, K, r, vol, ttm):
    return St * norm.cdf(d1(St, K, r, vol, ttm)) - K * exp(-r*ttm)*norm.cdf(d2(St, K, r, vol, ttm))

s = 800
# strikes expressed as % of spot price
moneyness = [0.5, 0.75, 0.825, 1.0, 1.125, 1.25, 1.5]
vol = 0.3
ttm = 0.75
r = 0.005

result = {}
for m in moneyness:
    result[s*m] = call(s, m*s, r, vol, ttm)
print(result)

{400.0: 401.66074527896365,
  600.0: 213.9883852521275,
  660.0: 166.85957363897393,
  800.0: 84.03697017660357,
  900.0: 47.61880394696229,
  1000.0: 25.632722952585738,
  1200.0: 6.655275227771156}
\end{ipython}
\end{solution}

\cprotEnv\begin{question}
Write two classes, \texttt{Circle} and \texttt{Rectangle} that given the radius and height, width respectively allow to compute area and perimeter of the two shapes. Test them with the following:

\begin{ipython}
a_circle = Circle(5)
print("My circle has an area of {} m2".format(a_circle.area()))

a_rectangle = Rectangle(3, 6)
print ("My rectangle has a perimeter of {} m and an area of {} m2".format(a_rectangle.perimeter(), a_rectangle.area())}
\end{ipython}
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
from math import pi

class Circle:
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return pi*self.radius**2

class Rectangle:
    def __init__(self, width, height):
        self.height = height
        self.width = width

    def area(self):
        return self.width*self.height

    def perimeter(self):
        return self.width*2 + self.height*2

circle = Circle(5)
print ("My circle area is {:.1f} m**2".format(circle.area()))

rect = Rectangle(3, 6)
print ("My rect area is {:.1f} m**2 and the perimeter is {} m".format(rect.area(), rect.perimeter()))

My circle area is 78.5 m**2
My rect area is 18.0 m**2 and the perimeter is 18 m
\end{ipython}
\end{solution}

\cprotEnv\begin{question}
Define a class \texttt{Songs}, its \texttt{\_\_init\_\_} should take as input a dictionary (\texttt{lyrics} that contains lyrics line by line). Define a method, \texttt{sing\_me\_a\_song} that prints each element of the lyrics in his own line. Also test it with the following input.

\begin{ipython}
lyrics = {"Wonderwall":["Today is gonna be the day",
	                    "That they're gonna throw it back to you",
	                    "By now you should've somehow", "..."],
	      "Wish you were here": ["So, so you think you can tell",
                                 "Heaven from hell",
	                             "Blue skies from pain", "..."]}
\end{ipython}
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
class Songs:
    def __init__(self, lyrics):
        self.lyrics = lyrics

    def sing_me_a_song(self, title):
        song = self.lyrics[title]
        print ("Title: {}".format(title))
        print ("********************")
        for line in song:
            print (line)

lyrics = {"Wonderwall":["Today is gonna be the day",	
	                    "That they're gonna throw it back to you",
	                    "By now you should've somehow", "..."],
	      "Wish you were here": ["So, so you think you can tell",
                        "Heaven from hell",
                        "Blue skies from pain", "..."]}

songs = Songs(lyrics)
songs.sing_me_a_song("Wonderwall")

Title: Wonderwall
********************
Today is gonna be the day
That they're gonna throw it back to you
By now you should've somehow
...
\end{ipython}
\end{solution}

\begin{question}
Define a Point2D class that represent a point in a plane. Its \texttt{\_\_init\_\_} method should accept the point coordinates \texttt{x} and \texttt{y}. Write a method \texttt{distanceTo} that compute the distance of the point to another passed as input. Test the class by printing the distance of the point \(P=(4, 5)\) to the origin \(P=(0,0)\) and to \(P=(3,4)\).

\noindent\textbf{Hint:} in the Cartesian plane the distance between two points is: $\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}$.
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
from math import sqrt

class Point2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def distanceTo(self, x, y):
        dist = sqrt((self.x-x)**2 + (self.y - y)**2)
        return dist

    def distanceTo_v2(self, p):
        dist = sqrt((self.x-p[0])**2 + (self.y - p[1])**2)
        return dist

    def distanceTo_v3(self, p):
        dist = sqrt((self.x-p.x)**2 + (self.y - p.y)**2)
        return dist

point = Point2D(4, 5)
p0 = (0, 0)
point0 = Point2D(0, 0)
print ("distance to p0: {:.2f}".format(point.distanceTo(p0[0], p0[1])))
print ("distance_v2 to p0: {:.2f}".format(point.distanceTo_v2(p0)))
print ("distance_v3 to p0: {:.2f}".format(point.distanceTo_v3(point0)))
p1 = (3, 4)
point1 = Point2D(3, 4)
print ("distance to p1: {:.2f}".format(point.distanceTo(p1[0], p1[1])))
print ("distance_v2 to p1: {:.2f}".format(point.distanceTo_v2(p1)))
print ("distance_v3 to p1: {:.2f}".format(point.distanceTo_v3(point1)))

distance to p0: 6.40
distance\_v2 to p0: 6.40
distance\_v3 to p0: 6.40
distance to p1: 1.41
distance\_v2 to p1: 1.41
distance\_v3 to p1: 1.41
\end{ipython}
\end{solution}

\cprotEnv\begin{question}
Write a class \texttt{Student} which inherits from the class \texttt{Person} defined in Chapter Object Oriented Programming in Python. This new class should have two new attributes: \texttt{grade} which keeps the type of school and \texttt{votes} a dictionary which will record the student's votes and the corresponding course. Then add two methods, one to add votes and another to compute the average vote.Instantiate a "student" add some votes and show how good it has been.

\noindent\textbf{Hint:} this is the \texttt{Person} class already developed.

\begin{ipython}
class Person:
    def __init__(self, name, birthday):
        self.name = name
        self.birthday = birthday
        self.employment = None

    def age(self, d=date.today()):
        age = (d - self.birthday).days/365
        print ("{} is {:.0f} years old".format(self.name, age))

    def mainOccupation(self, occupation):
        self.employment = occupation
        print ("{}'s main occupation is: {}".format(self.name, self.employment))
\end{ipython}
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
class Student(Person):
    def __init__(self, name, birthday, school):
        Person.__init__(self, name, birthday)
        self.grade = school
        self.votes = {}

    def addVote(self, subject, vote):
        self.votes[subject] = vote

    def average(self):
        print ("List of votes")
        print ("-------------")
        for k, v in self.votes.items():
            print ("{}: {}".format(k, v))
        avg = sum(self.votes.values())/len(self.votes)
        print ("-------------")
        print ("Avg: {:.1f}".format(avg))

student = Student("Mario", date(1980, 5, 6), "Liceo Scientifico G. Galilei")
student.addVote("Calculus", 8)
student.addVote("Literature", 5.5)
student.addVote("Latin", 6.5)
student.average()

List of votes
-------------
Calculus: 8
Literature: 5.5
Latin: 6.5
-------------
Avg: 6.7
\end{ipython}
\end{solution}
