\chapter{Interest Rate Derivatives}
\label{interest-rate-swaps-and-swaptions}

In Chapter~\ref{sec:swaps-and-bootstrapping} we introduced a particular type of swap, the Overnight Index Swap. Here we describe the general Interest Rate Swap contract and see how it can underlying a Swaption, the analogous of the European options for interest rate market.

\section{Interest Rate Swaps}\label{interest-rate-swaps}

Interest rate swaps (IRS) consist of two legs: floating and fixed. The contract parameters are:

\begin{itemize}
\tightlist
\item
  start date \(d_0\);
\item
  notional \(N\);
\item
  fixed rate \(K\);
\item
  floating rate tenor (months);
\item
  maturity (years).
\end{itemize}

The floating leg pays the reference EURIBOR fixing at a frequency equal to the tenor of the floating rate, so for example an IRS on a 3-month EURIBOR will pay a floating coupon every three months.

The fixed leg pays a predetermined cash flow at annual frequency, regardless of the underlying floating rate tenor (for simplicity we will only consider swaps with maturities which are multiples of 1 year).

\begin{finmarkets}
Before going into the details of the IRS valuation, we need to modify the \texttt{generate\_dates} function in \texttt{finmarkets} module to generate the payment dates for both the fixed and floating legs. 
The modification consists of the addition of a new input parameter, the tenor, which was previously fixed to 12 months.

Setting the default value of \texttt{tenor\_months} to 12 allows the new function to be \emph{backward-compatible}, meaning that old code based on its previous version will keep working, being written on the assumption of a fixed tenor of twelve months. 
\end{finmarkets}

\begin{ipython}
from datetime import date
from dateutil.relativedelta import relativedelta

def generate_dates(start_date, n_months, tenor_months=12):
    dates = []
    for n in range(0, n_months, tenor_months):
        dates.append(start_date + relativedelta(months=n))
    dates.append(start_date + relativedelta(months=n_months))
    return dates
    
generate_dates(date.today(), 16, 3)
\end{ipython}
\begin{ioutput}
[datetime.date(2020, 10, 15),
 datetime.date(2021, 1, 15),
 datetime.date(2021, 4, 15),
 datetime.date(2021, 7, 15),
 datetime.date(2021, 10, 15),
 datetime.date(2022, 1, 15),
 datetime.date(2022, 2, 15)]
\end{ioutput}
       
Using this function and the contract parameters we will be able to determine a sequence of payment dates for each leg of the IRS.

\subsection{IRS Valuation}
\label{irs-valuation}
Let \(d_0^{\mathrm{fixed}},...,d_p^{\mathrm{fixed}}\) be the fixed leg payment dates and \(d_0^{\mathrm{float}},...,d_p^{\mathrm{float}}\) be the floating leg payment dates and let's use the following notation:

\begin{itemize}
\tightlist
\item
  \(d\) the pricing date;
\item
  \(D(d, d')\) the discount factor observed in date \(d\) for the value date \(d'\);
\item
  \(F(d, d', d'')\) the forward rate observed in date \(d\) for the period \([d', d'']\); 
  \item the tenor is \(\tau = d' - d\).
\end{itemize}
The NPV of the fixed leg is calculated as follows:

\begin{equation}
\mathrm{NPV}_{\mathrm{fixed}}(d, K) = N\cdot K\cdot\sum_{i=1}^{n}D(d, d_{i}^{\mathrm{fixed}})\end{equation}
while the NPV of the floating leg is:

\begin{equation}\mathrm{NPV}_{\mathrm{float}}(d) = N\cdot\sum_{i=1}^{m}F(d, d_{j-1}^{\mathrm{float}}, d_{j}^{\mathrm{float}}) \cdot \frac{d_{j}^{\mathrm{float}}-d_{j-1}^{\mathrm{float}}}{360}
\cdot D(d, d_{i}^{\mathrm{float}})\end{equation}

Therefore the NPV of the swap (seen from the point of view of the counter-party which receives the floating leg) is

\begin{equation}\mathrm{NPV}(d, K) = \mathrm{NPV}_{\mathrm{float}}(d) - \mathrm{NPV}_{\mathrm{fixed}}(d, K)\end{equation}

For reasons which will become apparent later, it's actually more convenient to express the NPV of an IRS as a function of the fair value fixed rate $S$ of the IRS, also known as the \textbf{swap rate}, which is the value of $K$ which makes \(\mathrm{NPV}=0\). On the basis of the previous expressions, we can easily calculate $S$ as

\begin{equation}
\begin{gathered}
\mathrm{NPV}_{\mathrm{fixed}}(d, S) = \mathrm{NPV}_{\mathrm{float}}(d)\\[5pt]
N\cdot S\cdot\sum_{i=1}^{n}D(d, d_{i}^{\mathrm{fixed}}) = N\cdot\sum_{i=1}^{m}F(d, d_{j-1}^{\mathrm{float}}, d_{j}^{\mathrm{float}}) \cdot \frac{d_{j}^{\mathrm{float}}-d_{j-1}^{\mathrm{float}}}{360} \cdot D(d, d_{i}^{\mathrm{float}})\\[5pt]
S=\frac{\sum_{i=1}^{m}F(d, d_{j-1}^{\mathrm{float}}, d_{j}^{\mathrm{float}}) \cdot \frac{d_{j}^{\mathrm{float}}-d_{j-1}^{\mathrm{float}}}{360}
\cdot D(d, d_{i}^{\mathrm{float}})}{\sum_{i=1}^{n}D(d, d_i^{\mathrm{fixed}})}
\end{gathered}
\end{equation}

Once we have calculated \(S\), we can express the \(\mathrm{NPV}\) of an IRS as follows:

\begin{equation}
\begin{split}&\mathrm{NPV}(d, K) = \mathrm{NPV}_{\mathrm{float}}(d) - \mathrm{NPV}_{\mathrm{fixed}}(d, K) = \\ 
&= \underbrace{\mathrm{NPV}_{\mathrm{float}}(d) - \mathrm{NPV}_{\mathrm{fixed}}(d, S)}_{\textstyle\mathrm{=0}} + \mathrm{NPV}_{\mathrm{fixed}}(d, S) - \mathrm{NPV}_{\mathrm{fixed}}(d, K) \\ 
& = N\cdot(S-K)\cdot\underbrace{\sum_{i=1}^{n}D(d, d_{i}^{\mathrm{fixed}})}_{\textstyle \mathrm{'annuity'}}
\end{split}
\end{equation}

\begin{finmarkets}
Now a \texttt{InterestRateSwap} class can be implemented to valuate IRS contracts.
This class goes into \texttt{finmarkets} financial module to manage Interest Rate Swaps.
\end{finmarkets}

\begin{ipython}
class InterestRateSwap:
    def __init__(self, notional, start_date, fixed_rate,
                 tenor_months, maturity_years):
        self.notional = notional
        self.fixed_rate = fixed_rate
        self.fixed_leg_dates = \
            generate_dates(start_date, 12 * maturity_years)
        self.floating_leg_dates = \
            generate_dates(start_date, 12 * maturity_years, tenor_months)
    
    def annuity(self, discount_curve):
        a = 0
        for i in range(1, len(self.fixed_leg_dates)):
            a += discount_curve.df(self.fixed_leg_dates[i])
        return a

    def swap_rate(self, discount_curve, euribor_curve):
        s = 0
        for j in range(1, len(self.floating_leg_dates)):
            F = euribor_curve.forward_rate(self.floating_leg_dates[j], self.floating_leg_dates[j-1])
            tau = (self.floating_leg_dates[j] - \
                self.floating_leg_dates[j-1]).days / 360 
            P = discount_curve.df(self.floating_leg_dates[j])
            s += F * tau * P
        return s / self.annuity(discount_curve)

    def npv(self, discount_curve, euribor_curve):
        S = self.swap_rate(discount_curve, euribor_curve)
        A = self.annuity(discount_curve)
        return self.notional * (S - self.fixed_rate) * A
\end{ipython}

For convenience the relevant inputs that will be used later (EURIBOR and discount curve definitions) have been saved in the files  \href{https://github.com/matteosan1/finance_course/blob/develop/libro/input_files/euribor_curve.xlsx?raw=true}{euribor\_curve.xlsx} and \href{https://github.com/matteosan1/finance_course/raw/develop/libro/input_files/discount_curve.xlsx}{discount\_curve.xlsx} respectively.

\begin{ipython}
import pandas as pd
from datetime import date
from finmarkets import DiscountCurve, ForwardRateCurve

pricing_date = date(2020, 10, 20)
discount_data = pd.read_excel('discount_curve.xlsx')
euribor_data = pd.read_excel('euribor_curve.xlsx')

dc = DiscountCurve(discount_data.loc[:, 'pillars'].dt.date,
                   discount_data.loc[:, 'discount_factors'])
                   
fc = ForwardRateCurve(pricing_date, 
                      euribor_data.loc[:, 'date'].dt.date,
                      euribor_data.loc[:, 'rate'])

print (dc.df(date(2021, 1, 1)))
print (fc.forward_rate(pricing_date, date(2021, 7, 2)))
\end{ipython}
\begin{ioutput}
1.0039420028660369
0.010070410958904109
\end{ioutput}

Let's test our class instantiating an IRS with 1~M notional, fixed rate of 5\%, 6 month tenor and a maturity of 4 years.

\begin{ipython}
pricing_date = date.today()
start_date = date.today() + relativedelta(months=1)
irs = InterestRateSwap(1e6, start_date, 0.05, 6, 4)
print ("{:.2f} EUR".format(irs.npv(dc, fc)))
\end{ipython}
\begin{ioutput}
-158942.33 EUR
\end{ioutput}

\textbf{Can you guess what could be the \textbf{swap rate} given that the NPV obtained above ?}

Since we are looking at this contracts from the point of view of the receiver of the floating leg and that the swap rate is the rate that makes the total NPV equal to 0, the NPV of the fixed leg has to be decreased to balance the value of the floating leg so the swap rate will be lower than the fixed rate of the IRS.

\begin{ipython}
print ("{:.5f}".format(irs.swap_rate(dc, fc)))
\end{ipython}
\begin{ioutput}
0.01055
\end{ioutput}
    
To check if we have computed correctly the swap rate we can instantiate a new IRS with fixed rate equal to the just calculated swap rate and print its NPV, it should come very close to 0.

\begin{ipython}
irs2 = InterestRateSwap(1e6, start_date, 0.01055, 6, 4)
print ("{:.2f} EUR".format(irs2.npv(dc, fc)))
\end{ipython}
\begin{ioutput}
14.84 EUR
\end{ioutput}

The result is not exactly zero since in the calculation it has been used a rounded version of the swap rate, you can check it by replacing 0.01055 with the exact value coming from the previous evaluation. 
   
\section{Inheritance Again}
\begin{finmarkets}
Now that we have introduced two kinds of swap we can try to make an alternative implementation of their classes, this time using inheritance.

The base (or parent) class will be \texttt{GenericSwap} and it will implement just a constructor with the attributes given by the basic characteristics of a swap: notional, maturity, tenor and rate of the fixed leg.
\end{finmarkets}

\begin{ipython}
class GenericSwap:
    def __init__(self, start_date, notional,
                 fixed_rate, maturity_years, tenor_months=12):        
        self.notional = notional
        self.fixed_rate = fixed_rate
        self.fixed_leg_dates = \
            generate_swap_dates(start_date, 12 * maturity_years)
        self.floating_leg_dates = \
            generate_swap_dates(start_date, 12 * maturity_years, tenor_months)
        self.maturity = maturity_years

    def npv(self):
        print ("{} doesn't implement npv method.".format(self.__name__))

class OvernightIndexSwap(GenericSwap):
    def npv_floating_leg(self, discount_curve):
        return self.notional * (discount_curve.df(self.floating_leg_dates[0]) -
            discount_curve.df(self.floating_leg_dates[-1]))

    def npv_fixed_leg(self, discount_curve):
        npv = 0
        for i in range(1, len(self.fixed_leg_dates)):
            start_date = self.fixed_leg_dates[i-1]
            end_date = self.fixed_leg_dates[i]
            tau = (end_date - start_date).days / 360
            df = discount_curve.df(end_date)
            npv += df * tau 
        return self.notional * self.fixed_rate * npv

    def npv(self, discount_curve):
        float_npv = self.npv_floating_leg(discount_curve)
        fixed_npv = self.npv_fixed_leg(discount_curve)
        return float_npv - fixed_npv

class InterestRateSwap(GenericSwap):
    def annuity(self, discount_curve):
        a = 0
        for i in range(1, len(self.fixed_leg_dates)):
            a += discount_curve.df(self.fixed_leg_dates[i])
        return a

    def swap_rate(self, discount_curve, euribor_curve):
        s = 0
        for j in range(1, len(self.floating_leg_dates)):
            F = euribor_curve.forward_rate(self.floating_leg_dates[j], 
            self.floating_leg_dates[j-1])
            tau = (self.floating_leg_dates[j] - \
                self.floating_leg_dates[j-1]).days / 360
            P = discount_curve.df(self.floating_leg_dates[j])
            s += F * tau * P
        return s / self.annuity(discount_curve)

    def npv(self, discount_curve, euribor_curve):
        S = self.swap_rate(discount_curve, euribor_curve)
        A = self.annuity(discount_curve)
        return self.notional * (S - self.fixed_rate) * A
\end{ipython}
\begin{finmarkets}
This is just an example. Actually may be an overkill to use inheritance here, since there is not much code to share between the classes (the implementation of the NPV calculation is different in each of them). Anyway this is a practical application to show how it works.
\end{finmarkets}

\section{Swaptions}
\label{interest-rate-swaptions}

Swaptions are the equivalent of European options for the interest rate markets. They give the option holder the right but not the obligation to enter into an interest rate swap at a predetermined fixed rate at the exercise date \(d_{ex}\).

Clearly the option holder will only choose to do this if the NPV of the underlying swap at \(d_{ex}\) is positive. Looking at the expression of the IRS NPV in terms of the swap rate \(S\) therefore, we can see that the payoff of the swaption is

\begin{equation}
\mathrm{payoff} = N\cdot \mathrm{max}(0, S(d_{\mathrm{ex}}) - K)\cdot\sum D(d, d_i^{\mathrm{fixed}})
\label{eq:swaption_payoff}
\end{equation}

The primary risk with a swaption occurs after you have exercised your right and proceeded with the swap. If the interest rate movements were different to your expectations, the swap might have the opposite effect to what you were trying to achieve with the transaction. In case you can however reverse or terminate the swap although you may be required to pay the bank for the residual value of the swap.

It is also important to note, that if interest rates do not rise above the swaption strike on the exercise date, you have not obtained any benefit from the premium paid for the swaption purchase (the premium is the cost of obtaining protection against a rise in interest rates).

\subsection{Swaption Evaluation}

In order to evaluate the swaption payoff the key issue is to estimate $S(d_{\mathrm{ex}})$ and it will be done with two alternative approaches.

\subsubsection{Evaluation through Black-Scholes Formula}
\label{evaluation-through-black-scholes-formula}

In this case, to evaluate the swaption NPV, we are going to use (but not to derive) a generalization of the Black-Scholes formula

\begin{equation}
\mathrm{payoff} = N\cdot A\cdot [S \Phi(d_+) - K\Phi(d_-)]
\end{equation}
where $\Phi$ represents the cumulative distribution function of the normal distribution and

\begin{equation}
\begin{gathered}d_{\pm} = \frac{\mathrm{log}(\frac{S}{K}) \pm \frac{1}{2}\sigma^{2}T}{\sigma\sqrt{T}}\qquad(\sigma~\textrm{is the volatility of the swap rate})\\
A =\sum_{i=1}^{p}D(d, d_{i}^{\mathrm{fixed}})\qquad\mathrm{(annuity})
\end{gathered}
\end{equation}

As an example let's consider a swaption whose underlying 12M-IRS has a notional of 1~M, fixed rate of 5\%, and a maturity of 4 years. In addition we assume a volatility associated to the swap rate of 7\%.

\begin{ipython}
from math import log
from scipy.stats import norm
from dateutil.relativedelta import relativedelta

def npvSwaptionBS(irs, sigma, discount_curve, euribor_curve, T):
    A = irs.annuity(discount_curve)
    S = irs.swap_rate(discount_curve, euribor_curve)
    K = irs.fixed_rate
    N = irs.notional
    d_plus = (log(S/K) + 0.5 * sigma**2 * T) / (sigma * T**0.5)
    d_minus = (log(S/K) - 0.5 * sigma**2 * T) / (sigma * T**0.5)
    return irs.notional * A * (S * norm.cdf(d_plus) - K * norm.cdf(d_minus))

sigma = 0.07
pricing_date = date(2019, 11, 15)
exercise_date = start_date
irs = InterestRateSwap(1e6, start_date, 0.05, 12, 4)
T = (exercise_date - pricing_date).days / 365
npv = npvSwaptionBS()irs, sigma, dc, fc, T)
print("Swaption NPV with BS: {:.0f} EUR".format(npv))
\end{ipython}
\begin{ioutput}
Swaption NPV with BS: 88300 EUR
\end{ioutput}

\subsubsection{Evaluation through Monte Carlo Simulation}
\label{evaluation-through-monte-carlo-simulation}

In this second case we start from the current swap rate \(S(d)\) evaluated at the pricing date \(d\) and assume that it follows a log-normal stochastic process with zero drift, i.e. its distribution at \(d_{\mathrm{ex}}\) (exercise date) is 

\(S(d_{\mathrm{ex}}) = S(d)\mathrm{exp}(-\frac{1}{2}\sigma^{2}T+\sigma Z\sqrt{T})\)
\noindent
where $Z\approx\mathcal{N}(0,1)$. %This assumption is not correct since we know that interest rate follows different processes, but it is ok for illustrative purposes. 

To perform the simulation Eq.~\ref{eq:swaption_payoff} can be used:

\begin{itemize}
\tightlist
\item sample the normal distribution \(\mathcal{N}(0, 1)\) to calculate a large number of scenarios for \(S(d_{\mathrm{ex}})\);
\item evaluate the underlying swap's NPV at the expiry date, and consequently the swaption's payoff, for each scenario;
\item take the average of these values to get the final estimate.
\end{itemize}

\begin{ipython}
import numpy as np
from math import exp, sqrt
from numpy.random import normal, seed

n_scenarios = 100000
discounted_payoffs = []
seed(1)
T = (exercise_date - pricing_date).days / 365
A = irs.annuity(dc, pricing_date)
S0 = irs.swap_rate(dc, lc, pricing_date)
for i_scenario in range(n_scenarios):
    S = S0 * exp(-0.5 * sigma * sigma * T +
        sigma * sqrt(T) * normal())
    swap_npv = irs.notional * max(0,S - irs.fixed_rate) * A
    discounted_payoffs.append(max(0, swap_npv))

npv_mc = np.mean(discounted_payoffs)
print("Swaption NPV: {:.0f} EUR".format(npv_mc))
\end{ipython}
\begin{ioutput}
Swaption NPV: 88303 EUR
\end{ioutput}

%Note that this is not \emph{strictly speaking} the correct way of
%calculating the swaption NPV, the reason being that one should calculate
%the swap NPV at the expiry date of the swaption, apply the payoff
%function max(0, \ldots{}) and \emph{then} discount from the expiry date
%to today.
%
%However, it's simpler to calculate it as above and it doesn't make any
%difference for the result, since
%\[ DF\cdot \mathrm{max}(0, \mathrm{SwapNPVAtExpiry}) = \mathrm{max}(0, DF \cdot\mathrm{SwapNPVAtExpiry}) \]

\begin{finmarkets}
Add to \texttt{finmarkets.py} a new class (e.g. \texttt{Swaption}) capable of valuting interest rate swaptions both with Monte Carlo simulation and Black-Scholes formula.
\end{finmarkets}

\subsection{Confidence Interval of MC Simulation}

Using the confidence interval~\ref{sec:confidence_interval} it can be checked whether the Monte Carlo estimate of the swaption payoff is in agreement with what computed using the Black-Scholes formula.
Let's then calculate the 95\% confidence level for the swaption simulation:

\begin{ipython}
npv_error = 1.96 * np.std(discounted_payoffs)/sqrt(n_scenarios)
print("Swaption NPV: {:.0f} EUR (+/- {:.0f} EUR with 95% confidence)"\
    .format(npv_mc, npv_error))
\end{ipython}
\begin{ioutput}
Swaption NPV: 88303 EUR (+/- 17 EUR with 95% confidence)
\end{ioutput}

The NPV calculated via the Black-Scholes formula falls well within the confidence interval produced by the Monte Carlo simulation:

\begin{itemize}
\tightlist
\item
  Swaption NPV (BS): \euro{88300}
\item
  Swaption NPV (MC): \euro{88303} $\pm$ 17
\end{itemize}
so we can assert that the two estimates are in agreement at the 95\% confidence level.

\section*{Exercises}
\input{ir_derivatives_ex_text}

\begin{thebibliography}{9}
\bibitem{bib:black_scholes_swaption} G. West and L. West, \href{http://janroman.dhis.org/finance/Black/IntroToBlack.pdf}{\emph{Introduction to Black's Model for Interest Rate Derivatives}}, Financial Modelling Agency [Online]
\end{thebibliography}