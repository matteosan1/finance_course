\cprotEnv\begin{question}
Write a program to compute the multiplication of following matrices

\begin{equation*}
[P] = \begin{bmatrix}
1& 0\\
0& 1
\end{bmatrix};\quad
[Q] = \begin{bmatrix}
	1& 2\\
	3& 4
\end{bmatrix}
\end{equation*}
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
import numpy as np
p = [[1, 0], [0, 1]]
q = [[1, 2], [3, 4]]
print("original matrix:")
print(p)
print(q)

result1 = np.dot(p, q)
print("Result of the said matrix multiplication:")
print(result1)
print(result2)
\end{ipython}
\begin{ioutput}
original matrix:
[[1, 0], [0, 1]]
[[1, 2], [3, 4]]
Result of the said matrix multiplication:
[[1 2]
 [3 4]]
\end{ioutput}
\end{solution}

\cprotEnv\begin{question}
Write a program to compute the eigenvalues and eigenvectors of a given square array

\begin{equation*}
	[M] = \begin{bmatrix}
		3& -2\\
		1& 0
	\end{bmatrix}
\end{equation*}
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
import numpy as np

m = np.array([[3, -2],[1, 0]])
print("Original matrix:")
print(m)

w, v = np.linalg.eig(m) 
print("Eigenvalues of the said matrix", w)
print("Eigenvectors of the said matrix", v)
\end{ipython}
\begin{ioutput}

Original matrix:
[[ 3 -2]
 [ 1  0]]
Eigenvalues of the said matrix [ 2.  1.]
Eigenvectors of the said matrix [[ 0.89442719  0.70710678]
                                 [ 0.4472136   0.70710678]]
\end{ioutput}
\end{solution}

\cprotEnv\begin{question}
Write a program to compute the inverse of a given matrix

\begin{equation*}
	[M] = \begin{bmatrix}
		1& 2\\
		3& 4
	\end{bmatrix}
\end{equation*}
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
import numpy as np

m = np.array([[1,2],[3,4]])

print("Original matrix:")
print(m)

result =  np.linalg.inv(m)
print("Inverse of the said matrix:")
print(result)
\end{ipython}
\begin{ioutput}

Original matrix:
[[1 2]
 [3 4]]
Inverse of the said matrix:
[[-2.   1. ]
 [ 1.5 -0.5]]
\end{ioutput}
\end{solution}

\cprotEnv\begin{question}
A \emph{vampire number} is a composite number with an even number of digits, that can be factored into two natural numbers each with half as many digits as the original number, where the two factors (called \emph{fangs}) contain precisely all the digits of the original number (in any order). The first vampire number is $1260 = 21 \times 60$.

Similarly a \emph{vampire matrix} is a matrix such that squaring it, the resulting matrix elements are vampire numbers. An example is:
\begin{equation*}
\begin{bmatrix}
23 & 76 \\
69 & 78 \\
\end{bmatrix}^{2} =
\begin{bmatrix}
2323 & 7676 \\
6969 & 7878 \\
\end{bmatrix}
\end{equation*}

A ($2`times 2$) vampire matrix with three digits elements $[M]$ must satisfy the following conditions
\begin{equation*}
[M]^2 = 1001 [M]
\end{equation*}
\noindent
Implement an algorithm to find the first three $2\times 2$ vampire matrices with three digits elements (i.e. the elements to try must be in $[100,999]$ range). 
\end{question}
\cprotEnv\begin{solution}
\begin{ipython}
import numpy as np

successes = 0
factor = 1001

for i1 in range(100, 1000):
    for i2 in range(100, 1000):
        for i3 in range(100, 1000):
            for i4 in range(100, 1000):
                M = np.array([[i1, i2], [i3, i4]])
                M2 = np.dot(M, M)
                if np.array_equal(M2, factor*M):
                    successes += 1
                    print (M)
                    print (M2)
                    print ()
                    if successes == 3:
                        import sys
                        sys.exit()
\end{ipython}
\begin{ioutput}
[[100 100]
 [901 901]]
[[100100 100100]
 [901901 901901]]

[[100 106]
 [850 901]]
[[100100 106106]
 [850850 901901]]

[[100 170]
 [530 901]]
[[100100 170170]
 [530530 901901]]
\end{ioutput}
\end{solution}

\cprotEnv\begin{question}
Write a \texttt{numpy} program to get the lower-triangular $[L]$ in the Cholesky decomposition of the following array

\begin{equation*}
	[A] = \begin{bmatrix}
		4& 12 & -16\\
		12& 37 & -53\\
		-16& -53 & 98
	\end{bmatrix}
\end{equation*}
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
import numpy as np

a = np.array([[4, 12, -16], [12, 37, -53], [-16, -53, 98]])

print("Original array:")
print(a)

L = np.linalg.cholesky(a)
print("Lower-triangular L in the Cholesky decomposition of the said array:")
print(L)
\end{ipython}
\begin{ioutput}
Original array:
[[  4  12 -16]
 [ 12  37 -53]
 [-16 -53  98]]
Lower-triangular L in the Cholesky decomposition of the said array:
[[ 2.  0.  0.]
 [ 6.  1.  0.]
 [-8. -5.  3.]]
\end{ioutput}
\end{solution}

\cprotEnv\begin{question}

\end{question}
\cprotEnv\begin{solution}
\end{solution}