\begin{question}
Consider two 5\% coupon paying bonds (par value of \euro{100}) with the clean market prices of \euro{99.50} and \euro{98.30} and having maturities of 6 months and 1 year respectively.
Determine the spot rate for the 6-month and 1-year bond.  
\end{question}

\begin{solution}
At the end of 6 months the first bond will pay a coupon of \euro{2.5} (= \euro{100} * 5\%/ 2) plus the principal amount (= €100) which sums up to 102.50. To
determine the 6M spot rate we can write the following equation, :

\[ \cfrac{102.5}{(1 + S_{6M}/2)} = 99.5\qquad\Rightarrow\qquad S_{6M} = 2 \cdot \Big( \cfrac{102.5}{99.5} - 1 \Big) =  6.03 \%\]

At the end of another 6 months the second bond will pay a coupon of €2.5
(= €100 * 5\% / 2) plus the principal amount (= €100) which sums up to
€102.50. The bond is trading at €98.30, therefore, the 1-year spot rate
\(S_{1y}\) can be calculated using \(S_{6M}\) as,

\[ \cfrac{2.5}{(1+S_{6M}/2)} + \cfrac{102.5}{(1 + S_{1y}/2)^{2}} = 98.30 \]

\[ \cfrac{102.5}{(1 + S_{1y}/2)^{2}} = 98.30 - \cfrac{2.5}{(1+0.03015)} \]

\[ (2 + S_{1y})^{2} = \cfrac{4\cdot102.5}{98.87317} = 4.276428 \]

\[ S_{1y}^{2} + 4\cdot S_{1y} - 0.276428 = 0 \]

\[ S_{1y} = -2 \pm \sqrt{4 + 0.276428} =\begin{cases}\text{\sout{-4.06795}} \\ 6.80\%\end{cases} \]

\end{solution}

\begin{question}
A small petroleum company owns two refineries. Refinery 1 costs \$20,000 per day to operate, and it can produce 400 barrels of high-grade oil, 300 barrels of medium-grade oil, and 200 barrels of low-grade oil each day. Refinery 2 is newer and more modern. It costs \$25,000 per day to operate, and it can produce 300 barrels of high-grade oil, 400 barrels of medium-grade oil, and 500 barrels of low-grade oil each day.
The company has orders totaling 25,000 barrels of high-grade oil, 27,000 barrels of medium-grade oil, and 30,000 barrels of low-grade oil. How many days should it run each refinery to minimize its costs and still refine enough oil to meet its orders?

\noindent\textbf{Hint:} you need to identify the unknown quantities (working days for each refinery) and set the constraints on the production of barrels. The objective is to minimize the costs. If you have multiple constraints you can define a list of dictionaries (one for constraint). Furthermore in this case the constraint is not \emph{equal to} but rather \emph{greater than} so you have to set \texttt{ineq} type.
\end{question}

\cprotEnv\begin{solution}
Let's implement the usual steps for a minimization. In this case our unknown are \texttt{x[0]} and \texttt{x[1]} the working days for each refinery. Then define the objective function with the production costs and three more functions, one for each oil-grade for the constraints.

\begin{ipython}
from scipy.optimize import minimize

def of(x):
    return 20000*x[0] + 25000*x[1]

def cons1(x):
    return 400*x[0] + 300*x[1] - 25000

def cons2(x):
    return 300*x[0] + 400*x[1] - 27000

def cons3(x):
    return 200*x[0] + 500*x[1] - 30000

cons = [{"type":"ineq", "fun":cons1},
        {"type":"ineq", "fun":cons2},
        {"type":"ineq", "fun":cons3}]
\end{ipython}
Set limits and initial values and run the minimizer.
\begin{ipython}
x0 = [10, 10]
bounds = [(0, 100) for _ in range(len(x0))]
r = minimize(of, x0, bounds=bounds, constraints=cons)
print (r)

     fun: 1750002.070622686
     jac: array([20000., 25000.])
 message: 'Optimization terminated successfully.'
    nfev: 8
     nit: 6
    njev: 2
  status: 0
 success: True
       x: array([25.00004033, 50.00005056])
\end{ipython}    
So refinery 1 should work 25 days while refinery 2 50 days to minimize the production costs to 1750000 M (see objective function value in the minimization report).
\end{solution}

\begin{question}
Read the OIS market data from \href{https://drive.google.com/file/d/1LCEDmheKqwPXFpJ25hFz32QI5im2UJO1/view?usp=sharing}{\texttt{ois\_data.xlsx}} and, using the \texttt{OvernightIndexSwap} class,construct the corresponding swaps.
\end{question}

\cprotEnv\begin{solution}

\begin{ipython}
import pandas, datetime
from finmarkets import OvernightIndexSwap, generate_swap_dates

observation_date = datetime.date.today()
df = pandas.read_excel('ois_data.xlsx')

market_quotes = {}
for i in range(len(df)):
    key = df.loc[i, 'months']
    value = df.loc[i, 'quote']
    market_quotes[key] = value

swaps = []
for months, rate in market_quotes.items():
    swap = OvernightIndexSwap(1e6,
        generate_swap_dates(observation_date, months),
        0.01 * rate)

swaps.append(swap)
\end{ipython}
\end{solution}


\begin{question}
From the \texttt{OvernightIndexSwap} created in the previous example derive a discount curve using the bootstrap method.
\end{question}

\cprotEnv\begin{solution}
We have just created some swaps from the market quotes in the previous exercise, so now we can just create a list with the pillar dates.

\begin{ipython}
observation_date = date(2019, 10, 23)
pillar_dates = [observation_date]

for swap in swaps:
    pillar_dates.append(swap.payment_dates[-1])

# this shouldn't be necessary if the original
# list of market quotes is sorted
pillar_dates = sorted(pillar_dates)
\end{ipython}
Define the objective function: the sum of the squared NPVs of the OIS.
\begin{ipython}
def objective_function(x):
    curve = DiscountCurve(observation_date,
        pillar_dates, x)

    sum_sq = 0.0
    for swap in swaps:
        sum_sq += swap.npv(curve) ** 2
    return sum_sq
\end{ipython}
Set the initial value of the discount factors (\(x_i\)) to 1 with a range of variability \([ 0.01, 10]\), in addition the first element of the list, today's discount factor, will be fixed to 1 (variability \([1, 1]\)).

\begin{ipython}
x0 = [1.0 for i in range(len(pillar_dates))]

bounds = [(0.01, 10.0) for i in range(len(pillar_dates))]
bounds[0] = (1.0, 1.0)
\end{ipython}
Finally launch the minimizer to find the discount factors (\(\mathbf{x}\)).

\begin{ipython}
from scipy.optimize import minimize

result = minimize(objective_function, x0, bounds=bounds)
print (result)

     fun: 0.000819919032900304
hess_inv: <34x34 LbfgsInvHessProduct with dtype=float64>
     jac: array([ 6.58948735e+05, -1.58720803e+01, -6.53143264e+01, 
                 -1.03323232e+02, -1.26050260e+02, -1.31748898e+02, 
                 -1.20374599e+02, -9.15399651e+01, -4.24363322e+01,  
                  2.44903182e+01,  1.14345243e+02,  2.22002243e+02,
                 -3.72021700e+00,  4.21398633e+01,  4.21787852e+01,  
                  4.22369487e+01,  4.23327026e+01,  4.31814758e+01,  
                  4.44924460e+01,  4.62078978e+01,  4.82906823e+01, 
                  -3.69972738e+00,-1.42454702e+00,  7.53771932e-01,
                  2.79741018e+00,  4.62896699e+00,  6.24844054e+00,  
                  9.93101553e+00,  1.31122434e+01,  1.42880909e+01,  
                  1.48279215e+01,  1.50787019e+01,  1.43267935e+01,  
                  1.38451324e+01])
 message: b'CONVERGENCE: REL\_REDUCTION\_OF\_F\_<=\_FACTR*EPSMCH'
    nfev: 840
     nit: 7
  status: 0
 success: True
       x: array([1.        , 1.00030147, 1.00058831, 1.00089012, 1.00119726,
                 1.00147996, 1.00178743, 1.00208107, 1.00238467, 1.00267865,
                 1.00298261, 1.00327737, 1.00357104, 1.00357104, 1.00355063,
                 1.00352002, 1.00346901, 1.00302007, 1.00232627, 1.00141821,
                 1.00031629, 0.99911234, 0.99790839, 0.99675545, 0.99567393,
                 0.99470465, 0.9938476 , 0.99189884, 0.99021534, 0.98959296,
                 0.98930728, 0.98917464, 0.98957256, 0.98982763])
\end{ipython}
\end{solution}

\begin{question}
Take the \texttt{OvernightIndexSwap} class from \texttt{finmarkets} module and add a new method called \texttt{fair\_value\_strike} which takes a discount curve object and returns the fixed rate which would make the OIS with zero NPV.

\noindent\textbf{Hint:} first take the formulas for the NPV of the fixed and floating legs, put one equal to the other and solve for $K$.
\end{question}

\cprotEnv\begin{solution}
As the hint suggested the two NPV equations are compared:

\[\mathrm{NPV}_{\mathrm{fix}} = NK \sum_{i=1}^{n}D(d_{i})\cfrac{d_i - d_{i-1}}{360}\]

\[\mathrm{NPV}_{\mathrm{float}} = N \cdot [D(d_0) - D(d_n)]\]

\[K \sum_{i=1}^{n}D(d_{i})\cfrac{d_i - d_{i-1}}{360} = [D(d_0) - D(d_n)]\]

\[K = \cfrac{[D(d_0) - D(d_n)]}{\sum_{i=1}^{n}D(d_{i})\cfrac{d_i - d_{i-1}}{360}}\]
Now in \texttt{python}:

\begin{ipython}
class OverNightIndexSwap:
    ...
    def fair_value_strike(self, discount_curve):
        den = 0
        for i in range(1, len(self.payment_dates)):
            start_date = self.payment_dates[i-1]
            end_date = self.payment_dates[i]
            tau = (end_date - start_date).days / 360
            df = discount_curve.df(end_date)
            den += df * tau
            num = (discount_curve.df(self.payment_dates[0]) -
                discount_curve.df(self.payment_dates[-1]))
        return num/den
\end{ipython}
Finally add this method to the class implementation in \texttt{finmarkets.py}.
\end{solution}
