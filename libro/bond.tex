\chapter{Bonds}
\label{bonds}

A bond is an instrument that represents a loan made by an investor to a borrower (typically corporate or governmental). Bonds are used by companies, municipalities, states, and sovereign governments to finance projects and operations. 

Owners of bonds are debt-holders, or creditors, of the issuer. Bond details include the end date (when the principal of the loan is due to be paid to the bond owner) and usually includes the terms for variable or fixed interest payments made by the borrower.

The \emph{coupon} is the interest rate that the issuer pays to the holder. This rate can be fixed throughout the life of the bond but it can also vary with a money market index, such as LIBOR, or it can be even more exotic.

\section{Valuing a Bond}
\label{sec:bond_pricing}

The value of a bond can be computed as the present discounted value of future cash flows generated by the bond itself.

For example consider a 3-years bond with a face value of \euro{100} providing coupons at a 6\% rate annually. Assume also that the interest rates are 5.0\% 5.8\% and 6.4\% for 1, 2, 3 years. The value will be then:

\[P_{\mathrm{bond}}=6e^{-0.05\cdot 1}+6e^{-0.058\cdot 2}+106e^{-0.064\cdot 3} = \textrm{\euro{98.53}}\]

\begin{ipython}
from math import exp

rates = [0.05, 0.058, 0.064]
N = 100
maturity = 3
fixed_coupon = 0.06
price = 0

for tau in range(maturity):
    price += N * fixed_coupon * exp(-rates[tau] * (tau+1))
price += N * exp(-rates[tau] * (tau+1))

print ("{:.2f} EUR".format(price))
\end{ipython}
\begin{ioutput}
98.53 EUR
\end{ioutput}

\subsection{Yield to Maturity}
The \emph{yield to maturity} is the interest rate that makes the present value of the future coupon payments equal to the current bond price, that is, for a known price $P_0$, the yield is the solution $y$ to the equation

\begin{equation}
P = \sum_{t=1}^T e^{-yt}C + e^{-yT}N 
\label{eq:yield_to_maturity}
\end{equation}
where $C$ is the coupon end $N$ the nominal.

Finding the yield to maturity is equivalent to find the zeros of Eq.~\ref{eq:yield_to_maturity}.
To find the zeros of a function $f(x)$ means to determine the values $\hat{x}$ such that $f(\hat{x})=0$ and the process is equivalently called finding the roots of $f(x)$. There various methods to achieve that, in the following we will see two of them.

\emph{Bisection}~\cite{bib:bisection} method is considered the simplest one-dimensional root-finding algorithm.
Suppose we know two points of an interval $[a,b]$, and that $f (a)\lt 0$ and $f(b)\gt 0$.
Since the value of $f(a)$ is negative and $f(b)$ is positive, the bisection method assumes that the root $x$ lies somewhere between $a$ and $b$ and gives $f(x) = 0$.

Taking the midpoint of this $[a, b]$ interval as $c$, the bisection method then evaluates this value as $f(c)$.
If $f(c) = 0$ or is very close to zero by some predetermined error tolerance value, then a root is declared as found. If $f(c)\lt 0$, then we may conclude that a root exists along the interval $[c, b]$, or along the interval $[a,c]$ otherwise.

On the next evaluation, $c$ is replaced as either $a$ or $b$ accordingly. With the new interval shortened, the bisection method repeats with the same evaluation to determine the next value of $c$. This process continues, shrinking the width of the interval until the root is determined as found. Figure~\ref{fig:bisection} shows an example of bisection algorithm application.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.7\linewidth]{figures/bisection}
\caption{Example of bisection algorithm to find the roots of a function $f(x)$.}
\label{fig:bisection}
\end{figure}

The biggest advantage of using the bisection method is its guarantee to converge to an approximation of the root, given a predetermined error tolerance level and the maximum number of iterations allowed. It should be noted that the bisection method does not require knowledge of the derivative of the unknown function. In certain continuous functions, the derivative could be complex or even impossible to calculate. This makes the bisection method extremely valuable for working on functions that are not smooth.
Because of that, its major drawback is that it takes up more computational time in the iterative evaluation as compared to other root-finder methods. 

Although this method is simple enough to be quickly implemented in \texttt{python} we will opt for the surely bug free version available in \texttt{scipy.optimize.bisect}.

\begin{ipython}
from scipy.optimize import bisect 
from datetime import date
from finmarkets import generate_dates

def ytom(y, N, C, P0, start_date, maturity_years, tenor=1):
    price = 0
    payment_dates = generate_dates(start_date, maturity_years*12, tenor*12)

    for p in payment_dates[1:]:
        dt = (p - start_date).days/365
        price += C*tenor*N/(1+y)**dt 
    price += (1+y)**dt*N - P0
    return price
    
today = date.today()
print (bisect(bond_price, -0.99, 1, args=(100, 0.05, 95, today, 6, 0.5)))
\end{ipython}
\begin{ioutput}
0.06092598138641734
\end{ioutput}

An alternative algorithm is the \emph{Brent's method}~\cite{bib:brent} which combines the advantages of both bisection and secant (another root-finding algorithm) methods. Its \texttt{python} implementation is in \texttt{scipy.optimize.brentq}.

\begin{ipython}
from scipy.optimize import brentq
    
today = date.today()
print (brentq(ytom, -0.99, 1, args=(100, 0.05, 95, today, 6, 0.5)))
\end{ipython}
\begin{ioutput}
0.060925981384977894
\end{ioutput}

\noindent
The results match down to the eleventh digit.

\subsection{Duration}
The duration of a bond is the \emph{weighted average maturity} of the bond

\begin{equation}
\textrm{duration} = \sum_{i=1}^{n} t_i \left[\cfrac{C_i D_i}{P}\right] 
\end{equation}
where $C_i$ is the cash flow in period $t_i$, $D_i$ is the corresponding discount factor and $P$ is the bond price.
Knowing the bond yield from Eq.~\ref{eq:yield_to_maturity} the previous equation becomes:
\begin{equation}
\textrm{duration} = \sum_{i=1}^{n} t_i \left[\cfrac{C_i e^{-yt_i}}{P}\right] 
\label{eq:duration}
\end{equation}

This quantity is sometimes referred to as \emph{Macaulay Duration}. By accounting for the present value of future bond payments, the Macaulay duration helps an investor to evaluate and compare bonds independent of their time to maturity.
It estimates how many years it will take for an investor to be repaid the bond’s price by its total cash flows.

Imagine a three-year bond with a face value of \$100 that pays a 10\% coupon semi-annually and has a yield to maturity (YTM) of 6\%. We will first compute the present value of the bond and then calculate its Macaulay duration.

\begin{ipython}
def bond_pv(N, C, r, start_date, maturity_years, tenor=1):
    price = 0
    payment_dates = generate_dates(start_date, maturity_years*12, tenor*12)

    for p in payment_dates[1:]:
        dt = (p - start_date).days/365
        price += C*tenor*N/(1+r)**dt 
    price += N/(1+r)**dt
    return price
    
def mac_duration(N, C, y, P0, start_date, maturity_years, tenor=1):
    d = 0
    payment_dates = generate_dates(start_date, maturity_years*12, tenor*12)

    for p in payment_dates[1:]:
        dt = (p - start_date).days/365
        d += dt*C*tenor*N/(1+y)**dt/P0 
    d += dt*N/(1+y)**dt/P0
    return d

today = date.today()
P0 = bond_pv(100, 0.1, 0.06, today, 3, 0.5)
print ("Bond price: {:.2f}".format(P0))

dur = (mac_duration(100, 0.1, 0.06, P0, today, 3, 0.5))
print ("Duration: {:.2f}".format(dur))
\end{ipython}
\begin{ioutput}
Bond price: 111.08
Duration: 2.69
\end{ioutput}

This result can be interpreted by saying that it will take about two years and 7 months to be repaid for the bond expenses.

Equation~\ref{eq:duration} connects the bond price to the bond yield through duration. When a small change in yield $\Delta y$ happens
\begin{equation}
\Delta P = \cfrac{dP}{dy}\Delta y
\label{eq:price_1st_order}
\end{equation}
\noindent
Computing the derivative of the bond price from Eq.~\ref{eq:yield_to_maturity} we get

\begin{equation}
\Delta P = -\Delta y\sum_i C_i t_i e^{-yt_i}
\label{eq:price_yield}
\end{equation}
\noindent
which indicates there is a negative relationship between $P$ and $y$ (i.e. when bond yield increases the bond price decrease). 

Substituting Eq.~\ref{eq:duration} into Eq.~\ref{eq:price_yield} 
\begin{equation}
\Delta P = -PD\Delta y \quad\rightarrow\quad \cfrac{\Delta P}{P} = -D\Delta y
\label{eq:price_sens}
\end{equation}

This is an approximate relationship between percentage changes in a bond price and changes in its yield.

Consider a 3-year 10\% coupon bond with a face value of 100\$. Suppouse its yield is 12\% and that coupon payments of 5\$ are made every 6 months. Using the previous functions it is possible to compute bond price and duration

\begin{ipython}
today = date.today()

price = bond_pv(100, 0.1, 0.12, today, 3, 0.5)
print ("Price: {:.3f}".format(price))
dur = mac_duration(100, 0.1, 0.12, price, today, 3, 0.5)
print ("Duration: {:.3f}".format(dur))\end{ipython}
\begin{ioutput}
Price: 95.878
Duration: 2.658
\end{ioutput}

Replacing those values into Eq.~\ref{eq:price_sens} it is possible to estimate the sensitivity of the bond price to small changes of the yield.
Assuming for example an yield variation of 10 basis points
\begin{ipython}
dP = -price*dur*0.001
print ("DeltaP: {:.3f}".format(dP))
print ("P+DP: {:.3f}".format(price+dP))
\end{ipython}
\begin{ioutput}
DeltaP: -0.255
P+DP: 95.623
\end{ioutput}

To check how good is this approximation we can compute the bond price assuming the new yield
\begin{ipython}
today = date.today()

price = bond_pv(100, 0.1, 0.121, today, 3, 0.5)
print ("Price: {:.3f}".format(price))
\end{ipython}
\begin{ioutput}
Price: 95.651
\end{ioutput}

Which is in good agreement with the approximate calculation.
When the yield variation is larger the simple linear approximation is not valid anymore as shown in Fig.~\ref{fig:bond_sensitivity}.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.7\linewidth]{figures/bond_duration}
\caption{Bond price sensitivity to yield variation. For large movements of the yield the simple linear approximation given by
 Eq.~\ref{eq:price_sens} is not valid anymore.}
\label{fig:bond_sensitivity}
\end{figure}

\subsection{Price Value of a Basis Point}
A very common risk measure is the sensitivity of the price of a bond to changes in its yield. The price value of a basis point, PVBP, sometimes called the dollar value of a basis point, or $DV01$, measures the decline in price associated with a one basis point increase in the yield.

\begin{equation}
DV01 = −\cfrac{dP}{dy}\times 0.0001
\end{equation}

$DV01$ can be computed directly, by computing the price at the current yield, adding one basis point to the yield, and recomputing the price.

$DV01$ can also be computed directly from duration. In particular, we have seen that $dP/P = -D dy$. Hence $dP = -D Pdy$ and

\begin{equation}
DV01 = -D P \times 0.0001
\end{equation}

\subsubsection{Modified Duration}
In the previous analysis we have assumed continuous compounding. If instead $y$ is expressed with a compounding frequency of $m$ times per year then 
\begin{equation}
\Delta P = \cfrac{PD\Delta y}{1+y/m}
\end{equation}
\noindent
The quantity $D^{*}$, defined by
\begin{equation}
D^{*} = \cfrac{D}{1+y/m}
\end{equation}
\noindent
is referred to as \emph{modified duration}. 

\subsection{Convexity}
The duration relationship studied in the previous Section is valid only for small changes in yields. Since Eq.~\ref{eq:price_1st_order} is just a Taylor expansion to first order, to improve its accuracy we need to go to higher orders

\begin{equation}
\Delta P = \cfrac{dP}{dy}\Delta y + \cfrac{1}{2} \cfrac{d^2 P}{dy^2}\Delta y^2 = -D\Delta y + \cfrac{1}{2} \textrm{Conv} \Delta y^2 
\end{equation}
\noindent
The quantity $\textrm{Conv} = \frac{\sum_i C_i t_i^2 e^{-yt_i}}{P}$ is called \emph{convexity} and parametrizes the behaviour of the bond price for large yield variations.

Considering a portfolio of bonds, the convexity tends to be greatest when it provides payments evenly over a long period of time. Contrary it is least when the payments are concentrated around on particular point in time. 

Choosing a portfolio of assets with net duration and net convexity both close to zero, we make ourselves immune to relatively large shifts in the zero curve (i.e. large movements of the yield)

\subsection{Duration, Convecxity and $DV01$ of a Bond Portfolio}
The duration of a bond portfolio, $D_p$, is computed as the weighted average of the durations of the individual
bonds:
\begin{equation}
D_p = \sum_{i=1}^{K} \alpha_i D_i
\end{equation}
where $K$ is the number of different bonds and $\alpha_i$ is the fraction of portfolio dollars invested in bond $i$. Similarly, the convexity of a bond portfolio, Conv$_p$, is the weighted average of the convexities of the individual bonds.
\begin{equation}
\textrm{Conv}_p = \sum^{K}_{i=1} \alpha_i \textrm{Conv}_i
\end{equation}
The $DV01_p$ of a portfolio is defined as the change in value resulting from equal one basis point declines in all yields. Let $DV01_i$ represent the dollar value of a basis point associated with the i$^{th}$ bond. Then
\begin{equation}
DV01_p = \sum^{K}_{i=1}x_i DV01_i
\end{equation}
where $x_i$ is the number of bonds of type $i$ in the portfolio.

\section*{Exercises}
\input{bond_ex_text}

\begin{thebibliography}{9}
	\bibitem{bib:bisection}\href{https://en.wikipedia.org/wiki/Bisection_method}{\emph{Bisection Method}}, Wikipedia [Online]
	\bibitem{bib:brent} \href{https://en.wikipedia.org/wiki/Brent%27s_method}{\emph{Brent's Method}}, Wikipedia [Online]
\end{thebibliography}
