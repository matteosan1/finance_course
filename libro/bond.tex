\chapter{Bonds}
\label{bonds}

A bond is an instrument that represents a loan made by an investor to a borrower (typically corporate or governmental). Bonds are used by companies, municipalities, states, and sovereign governments to finance projects and operations. 

Owners of bonds are debt-holders, or creditors, of the issuer. Bond details include the end date (when the principal of the loan is due to be paid to the bond owner) and usually includes the terms for variable or fixed interest payments made by the borrower.

The \emph{coupon} is the interest rate that the issuer pays to the holder. This rate can be fixed throughout the life of the bond but it can also vary with a money market index, such as LIBOR, or it can be even more exotic.

\section{Valuing a Bond}
\label{sec:bond_pricing}

The value of a bond can be computed as the present discounted value of future cash flows generated by the bond itself.

For example consider a 3-years bond with a face value of \euro{100} providing coupons at a 6\% rate annually. Assume also that the interest rates are 5.0\% 5.8\% and 6.4\% for 1, 2, 3 years. The value will be then:

\[P_{\mathrm{bond}}=6e^{-0.05\cdot 1}+6e^{-0.058\cdot 2}+106e^{-0.064\cdot 3} = \textrm{\euro{98.53}}\]

\begin{ipython}
from math import exp

rates = [0.05, 0.058, 0.064, 0.068]
N = 100
maturity = 3
fixed_coupon = 0.06
price = 0

for tau in range(1, maturity + 1):
    price += N * fixed_coupon * exp(-rates[tau-1] * tau)
price += N * exp(-rates[maturity - 1] * maturity)

print ("{:.2f} EUR".format(price))
\end{ipython}
\begin{ioutput}
98.53 EUR
\end{ioutput}

\subsection{Yield to Maturity}
The \emph{yield to maturity} is the interest rate that makes the present value of the future coupon payments equal to the current bond price, that is, for a known price $P_0$, the yield is the solution $y$ to the equation

\begin{equation}
P = \sum_{t=1}^T e^{-yt}C + e^{-yT}N 
\label{eq:yield_to_maturity}
\end{equation}
where $C$ is the coupon end $N$ the nominal.

Finding the yield to maturity is equivalent to find the zeros of Eq.~\ref{eq:yield_to_maturity}, so the \texttt{brentq} algorithm (already used in Section~\ref{the-bootstrapping-technique}) method can be used again.

\begin{ipython}
from scipy.optimize import brentq
from finmarkets import generate_dates
from datetime import date
import math 

def bond_price(r, today, payment_dates, C, N, P0):
    price = 0
    for p in payment_dates:
        if p >= today:
            dt = (p - today).days/365
            price += math.exp(-r*dt)*C
    price += math.exp(-r*dt)*N - P0
    return price
    
today = date.today()
payment_dates = generate_dates(today, 12*5, 6)

print (brentq(bond_price, -1, 1, args=(today, payment_dates, 5, 100, 100)))
\end{ipython}
\begin{ioutput}
0.11019645500365874
\end{ioutput}

Alternatively it could be used the \emph{bisection}. Bisection method is considered the simplest one-dimensional root-finding algorithm. The general interest is to find the value $x$ of a continuous function $f$ such that $f(x)= 0$.

Suppose we know the two points of an interval $[a,b]$, and that $f (a)\lt 0$ and $f(b)\gt 0$.
Since the value of $f(a)$ is negative and $f(b)$ is positive, the bisection method assumes that the root $x$ lies somewhere between $a$ and $b$ and gives $f(x) = 0$.

Taking the midpoint of this $[a, b]$ interval as $c$, the bisection method then evaluates this value as $f(c)$.
If $f(c) = 0$ or is very close to zero by some predetermined error tolerance value, then a root is declared as found. If $f(c)\lt 0$, then we may conclude that a root exists along the interval $[c, b]$, or along the interval $[a,c]$ otherwise.

On the next evaluation, $c$ is replaced as either $a$ or $b$ accordingly. With the new interval shortened, the bisection method repeats with the same evaluation to determine the next value of $c$. This process continues, shrinking the width of the interval until the root is determined as found.

The biggest advantage of using the bisection method is its guarantee to converge to an approximation of the root, given a predetermined error tolerance level and the maximum number of iterations allowed. It should be noted that the bisection method does not require knowledge of the derivative of the unknown function. In certain continuous functions, the derivative could be complex or even impossible to calculate. This makes the bisection method extremely valuable for working on functions that are not smooth.
Because the bisection method does not require derivative information from the continuous function, its major drawback is that it takes up more computational time in the iterative evaluation as compared to other root-finder methods. 

Although this method is simple enough to be quickly implemented in \texttt{python} we will opt for the surely bug free version available in \texttt{scipy.optimize.bisect}.

\begin{ipython}
from scipy.optimize import bisect

print (bisect(bond_price, -1, 1, args=(today, payment_dates, 5, 100, 100)))
\end{ipython}
\begin{ioutput}
0.11019645500527986
\end{ioutput}

\noindent
The results match down to the eleventh digit.

\subsection{Duration}
The duration of a bond is the \emph{weighted average maturity} of the bond

\begin{equation}
\textrm{duration} = \sum_{i=1}^{n} t_i \left[\cfrac{C_i D_i}{P}\right] 
\end{equation}
where $C_i$ is the cash flow in period $t_i$, $D_i$ is the corresponding discount factor and $P$ is the bond price.
Knowing the bond yield from Eq.~\ref{eq:yield_to_maturity} the previous equation becomes:
\begin{equation}
\textrm{duration} = \sum_{i=1}^{n} t_i \left[\cfrac{C_i e^{-yt_i}}{P}\right] 
\label{eq:duration}
\end{equation}

This quantity is sometimes referred to as \emph{Macaulay Duration}. By accounting for the present value of future bond payments, the Macaulay duration helps an investor to evaluate and compare bonds independent of their time to maturity.
It estimates how many years it will take for an investor to be repaid the bond’s price by its total cash flows.

Imagine a three-year bond with a face value of \$100 that pays a 10\% coupon semi-annually and has a yield to maturity (YTM) of 6\%. We will first compute the present value of the bond and then calculate its Macaulay duration.

\begin{ipython}
from finmarkets import generate_swap_dates
from datetime import date
import math 

def bond_price(r, today, payment_dates, C, N, tenor):
    price = 0
    for p in payment_dates:
        if p > today:
            dt = (p - today).days/365
            price += math.exp(-r*dt)*C*tenor*N
    price += math.exp(-r*dt)*N
    return price

today = date.today()
payment_dates = generate_swap_dates(today, 12*3, 6)

print (bond_price(0.06, today, payment_dates, 0.1, 100, 0.5))
\end{ipython}
\begin{ioutput}
110.55442078433816
\end{ioutput}

\begin{ipython}
def mac_duration(today, payment_dates, r, C, N, tenor, P0):
    d = 0
    for p in payment_dates:
        if p > today:
            dt = (p - today).days/365
            d += dt*math.exp(-r*dt)*C*tenor*N/P0
    d += dt*math.exp(-r*dt)*N/P0
    return d

print (mac_duration(today, payment_dates, 0.06, 0.1, 100, 0.5, 110.55))
\end{ipython}
\begin{ioutput}
2.686350417638767
\end{ioutput}

This result can be interpreted by saying that it will take about two years and 7 months to be repaid for the bond expenses.

Equation~\ref{eq:duration} connects the bond price to the bond yield through duration. When a small change in yield $\Delta y$ happens
\begin{equation}
\Delta P = \cfrac{dP}{dy}\Delta y
\label{eq:price_1st_order}
\end{equation}
\noindent
Computing the derivative of the bond price from Eq.~\ref{eq:yield_to_maturity} we get

\begin{equation}
\Delta P = -\Delta y\sum_i C_i t_i e^{-yt_i}
\label{eq:price_yield}
\end{equation}
\noindent
which indicates there is a negative relationship between $P$ and $y$ (i.e. when bond yield increases the bond price decrease). 

Substituting Eq.~\ref{eq:duration} into Eq.~\ref{eq:price_yield} 
\begin{equation}
\Delta P = -PD\Delta y \quad\rightarrow\quad \cfrac{\Delta P}{P} = -D\Delta y
\label{eq:price_sens}
\end{equation}

This is an approximate relationship between percentage changes in a bond price and changes in its yield.

Consider a 3-year 10\% coupon bond with a face value of 100\$. Suppouse its yield is 12\% and that coupon payments of 5\$ are made every 6 months. Using the previous functions it is possible to compute bond price and duration

\begin{ipython}
today = date.today()
payment_dates = generate_swap_dates(today, 12*3, 6)

price = bond_price(0.12, today, payment_dates, 0.10, 100, 0.5)
print ("Price: {:.3f}".format(price))
dur = mac_duration(today, payment_dates, 0.12, 0.1, 100, 0.5, price)
print ("Duration: {:.3f}".format(dur))
\end{ipython}
\begin{ioutput}
Price: 94.183
Duration: 2.656
\end{ioutput}

Replacing those values into Eq.~\ref{eq:price_sens} it is possible to estimate the sensitivity of the bond price to small changes of the yield.
Assuming for example an yield variation of 10 basis points
\begin{ipython}
dP = -price*dur*0.001
print ("DeltaP: {:.3f}".format(dP))
print ("P+DP: {:.3f}".format(price+dP))
\end{ipython}
\begin{ioutput}
DeltaP: -0.250
P+DP: 93.933
\end{ioutput}

To check how good is this approximation we can compute the bond price assuming the new yield
\begin{ipython}
today = date.today()
payment_dates = generate_swap_dates(today, 12*3, 6)

price = bond_price(0.121, today, payment_dates, 0.10, 100, 0.5)
print ("Price: {:.3f}".format(price))
\end{ipython}
\begin{ioutput}
Price: 93.933
\end{ioutput}

Which is in very good agreement with the approximate calculation.

\subsubsection{Modified Duration}
In the previous analysis we have assumed continuous compounding. If instead $y$ is expressed with a compounding frequency of $m$ times per year then 
\begin{equation}
\Delta P = \cfrac{PD\Delta y}{1+y/m}
\end{equation}
\noindent
The quantity $D^{*}$, defined by
\begin{equation}
D^{*} = \cfrac{D}{1+y/m}
\end{equation}
\noindent
is referred to as \emph{modified duration}. 

\subsection{Convexity}
The duration relationship studied in the previous Section is valid only for small changes in yields. Since Eq.~\ref{eq:price_1st_order} is just a Taylor expansion to first order, to improve its accuracy we need to go to higher orders

\begin{equation}
\Delta P = \cfrac{dP}{dy}\Delta y + \cfrac{1}{2} \cfrac{d^2 P}{dy^2}\Delta y^2 = -D\Delta y + \cfrac{1}{2} \textrm{Conv} \Delta y^2 
\end{equation}
\noindent
The quantity $\textrm{Conv} = \frac{\sum_i C_i t_i^2 e^{-yt_i}}{P}$ is called \emph{convexity} and parametrizes the behaviour of the bond price for large yield variations.

Considering a portfolio of bonds, the convexity tends to be greatest when it provides payments evenly over a long period of time. Contrary it is least when the payments are concentrated around on particular point in time. 

Choosing a portfolio of assets with net duration and net convexity both close to zero, we make ourselves immune to relatively large shifts in the zero curve (i.e. large movements of the yield)

\subsection{Price Value of a Basis Point}
A very common risk measure is the sensitivity of the price of a bond to changes in its yield. The price value of a basis point, PVBP, sometimes called the dollar value of a basis point, or $DV01$, measures the decline in price associated with a one basis point increase in the yield.

\begin{equation}
DV01 = −\cfrac{dP}{dy}\times 0.0001
\end{equation}

$DV01$ can be computed directly, by computing the price at the current yield, adding one basis point to the yield, and recomputing the price.

As an example imagine a five year bond pays 10\% coupons semi annually and is priced at par. ($y = 0.10$). To compute $DV01$ we reprice the bond at a yield of 0.1001. This leads to a price of \$99.9614. Hence, $DV01$ = 100 - 99.9614 = \$0.0386.

$DV01$ can also be computed directly from modified duration. In particular, we have seen that $dP/P = -D_m dy$. Hence $dP = -D_m Pdy$ and

\begin{equation}
DV01 = -D_m P \times 0.0001
\end{equation}

Again reconsider our five year bond that pays 10\% coupons semi annually and is priced at par. ($y = 0.10$). The modified duration of this bond is $D_m = 3.86$. Hence $DV01 = 100 \cdot 3.86 \cdot 0.0001 = \$0.0386$.
