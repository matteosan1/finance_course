\chapter{Bonds}
\label{bonds}

A bond is an instrument that represents a loan made by an investor to a borrower (typically corporate or governmental). Bonds are used by companies, municipalities, states, and sovereign governments to finance projects and operations. 

Owners of bonds are debt-holders, or creditors, of the issuer. Bond details include the end date (when the principal of the loan is due to be paid to the bond owner) and usually includes the terms for variable or fixed interest payments made by the borrower.

The \emph{coupon} is the interest rate that the issuer pays to the holder. This rate can be fixed throughout the life of the bond but it can also vary with a money market index, such as LIBOR, or it can be even more exotic.

\section{Valuing a Bond}
\label{sec:bond_pricing}

The value of a bond can be computed as the present discounted value of future cash flows generated by the bond itself.

For example consider a 3-years bond with a face value of \euro{100} providing coupons at a 6\% rate annually. Assume also that the spot rates are 5.0\% 5.8\% and 6.4\% for 1, 2, 3 year maturities. To compute the present value of the first coupon we need to discount it at 5.0\% for 1 year, for the second the discount has to be at 5.8\% and so on. The value will be then:

\[P_{\mathrm{bond}}=6e^{-0.05\cdot 1}+6e^{-0.058\cdot 2}+106e^{-0.064\cdot 3} = \textrm{\euro{98.53}}\]

\begin{ipython}
from math import exp

rates = [0.05, 0.058, 0.064]
N = 100
maturity = 3
fixed_coupon = 0.06
price = 0

for tau in range(maturity):
    price += N * fixed_coupon * exp(-rates[tau] * (tau+1))
price += N * exp(-rates[tau] * (tau+1))

print ("{:.2f} EUR".format(price))
\end{ipython}
\begin{ioutput}
98.53 EUR
\end{ioutput}

\subsection{Yield to Maturity}
The \emph{yield to maturity} is the interest rate that makes the present value of the future coupon payments equal to the current bond price, that is, for a known price $P_0$, the yield is the solution $y$ to the equation

\begin{equation}
	P_0 = \sum_{t=1}^T e^{-yt}C + e^{-yT}F 
\label{eq:yield_to_maturity}
\end{equation}
where $C$ is the coupon end $F$ the nominal.

Finding the yield to maturity is equivalent to find the zeros of Eq.~\ref{eq:yield_to_maturity}, so the \texttt{brentq} method could be used.


%The bisection method
%The bisection method is considered the simplest one-dimensional root-finding algorithm. The general interest is to find the value x of a continuous function f such that f (x)= 0.
%Suppose we know the two points of an interval a and b, where a < b, and that
%f (a)< 0 and f (b)> 0 lie along the continuous function, taking the midpoint of this
%a+b
%interval as c , where c = 2 , the bisection method then evaluates this value as f(c).
%Let's illustrate the setup of points along a nonlinear function with the following graph:
%Since the value of f(a) is negative and f(b) is positive, the bisection method assumes that the root x lies somewhere between a and b and gives f (x) = 0.
%
%If f (c ) = 0 or is very close to zero by some predetermined error tolerance value, then a root is declared as found. If f (c)< 0, then we may conclude that a root exists along the interval c and b, or interval a and c otherwise.
%On the next evaluation, c is replaced as either a or b accordingly. With the new interval shortened, the bisection method repeats with the same evaluation to determine the next value of c . This process continues, shrinking the width of the interval ab until the root is determined as found.
%The biggest advantage of using the bisection method is its guarantee to converge to an approximation of the root, given a predetermined error tolerance level and the maximum number of iterations allowed. It should be noted that the bisection method does not require knowledge of the derivative of the unknown function. In certain continuous functions, the derivative could be complex or even impossible to calculate. This makes the bisection method extremely valuable for working on functions that are not smooth.
%Because the bisection method does not require derivative information from the continuous function, its major drawback is that it takes up more computational
%time in the iterative evaluation as compared to other root-finder methods. Also, since the search boundary of the bisection method lies in the intervals a and b, it would require a good approximation to ensure that the root falls within this range. Otherwise, a wrong solution may be obtained or even none at all. Using large values of a and b might consume more computational time.
%The bisection is considered to be stable without the use of an initial guess value for convergence to happen. Often, it is used in combination with other methods, such as the faster Newton's method, to converge quickly with precision.
%Save this file as bisection.py. The Python code for the bisection method is given as follows:
%""" The bisection method """
%def bisection(f, a, b, tol=0.1, maxiter=10): """
%:param f: The function to solve
%:param a: The x-axis value where f(a)<0 :param b: The x-axis value where f(b)>0 :param tol: The precision of the solution
%[ 59 ]
%
%Nonlinearity in Finance
%:param maxiter: Maximum number of iterations :return: The x-axis value of the root,
%number of iterations used
%"""
%c = (a+b)*0.5 # Declare c as the midpoint ab n = 1 # Start with 1 iteration
%while n <= maxiter:
%c = (a+b)*0.5
%if f(c) == 0 or abs(a-b)*0.5 < tol:
%# Root is found or is very close return c, n
%n += 1
%if f(c) < 0:
%a= c else:
%b= c
%return c, n
%Let's try out our bisection method:
%>>> y = lambda x: x**3 + 2*x**2 - 5
%>>> root, iterations = bisection(y, -5, 5, 0.00001, 100) >>> print "Root is:", root
%>>> print "Iterations: ", iterations
%Root is: 1.24190330505
%Iterations: 20
%Again, we bounded the anonymous function lambda to the variable y with an input parameter x and attempted to solve the equation y = x3 + 2x2 âˆ’ 5 as before in the interval between -5 to 5 to an accuracy of 0.00001 with a maximum iteration of 100.



Alternatively it could be implemented a simple bisection: since the yield is above zero we can start finding a "maximum" 
yield which gives a bond price $\hat{P}\gt P_0$. Then we bisect the interval until we get a $\hat{P}$ ``close enough''
to $P_0$.

\begin{ipython}
import math
from datetime import date
from finmarkets import generate_swap_dates

def bond_price(today, payment_dates, C, N, r):
    price = 0
    for p in payment_dates:
        if p >= today:
            dt = (p - today).days/365
            price += math.exp(-r*dt)*C
    price += math.exp(-r*dt)*N
    return price

def yield_to_maturity(today, payment_dates, C, N, P0):
    ACCURACY = 1e-5
    MAX_ITER = 200
    bot=0
    top=1
    while (bond_price(today, payment_dates, C, N, top) > P0):
        top = top*2
        r = 0.5 * (top + bot)
    for i in range(MAX_ITER):
        diff = bond_price(today, payment_dates, C, N, r) - P0
        if abs(diff) < ACCURACY:
            return r
        if diff > 0:
            bot = r
        else:
            top = r
    	r = 0.5 * (bot + top)
    return r

today = date.today()
payment_dates = generate_swap_dates(today, 12*5, 6)
print (yield_to_maturity(today, payment_dates, 5, 100, 100))
\end{ipython}
\begin{ioutput}
0.1102447509765625
\end{ioutput}

Notice that you could have used \texttt{scipy.optimize.bisect} algorithm which is the standard \texttt{python} 
implementation of the method.

\subsection{Duration}
The duration of a bond is the \emph{weighted average maturity} of the bond

\begin{equation}
	\textrm{duration} = \sum_t \frac{t C_t D}{P_0} 
\end{equation}
where $C_t$ is the cash flow in period $t$, $D$ is the discount factor and $P_0$ is the bond price.
There are two versions of the duration calculation, based on how one estimate the bond price. The first one assumes the current interest rate $r$ and calculates

\begin{equation}
	P_0 = \sum_{t=1}^T e^{-rt}C_t
\end{equation}

Alternatively one can calculate the yield to maturity for the bond, and use that in estimating the bond price. This is called \emph{Macaulay Duration} First one calculates $y$, the yield to maturity, from

\begin{equation}
	P_0 = \sum_{t=1}^T e^{-yt}C_t
\end{equation}
and then use this $y$ in the duration calculation.
The following code implements both algorithms.


\subsection{Modified Duration}
Modified duration is defined as

\begin{equation}
	\textrm{mod. duration} = \frac{\textrm{duration}}{\textrm{yield}} 
\end{equation}

\subsection{Bond convexity}
Convexity measures the curvature of the approximation done when using duration. It is calculated as

\begin{equation}
	\sum_{i=1}^nc_it_i^2e^{-yt_i}
\end{equation}

