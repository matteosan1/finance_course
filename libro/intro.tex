\chapter{Introduction to \texttt{python}}
\label{introduction-to-python}

\texttt{Python} is one of the most widely used programming languages in the world, and it has been around for almost 30 years now~\cite{survey2019}.

First and foremost reason why \texttt{python} is much popular because it is highly productive as compared to other programming languages like \texttt{C++} and \texttt{java}. It is a much more concise and expressive language and requires less time, effort, and lines of code to perform the same operations.

This makes \texttt{python} a very easy-to-learn programming language even for beginners and newbies. It is also very famous for its simple programming syntax, code readability and English-like commands that make coding in \texttt{python} lot easier and efficient.
With \texttt{python}, the code looks very close to how humans think. For this purpose, it must abstract the details of the computer from you. Hence, it is slower than other “lower-level language” like \texttt{C}.

There were times when computer run-time used to be the main issue and the most expensive resource. But now, things have changed. Computer, servers and other hardware have become much much cheaper than ever and speed has become a less important factor. Today, development time matters more in most cases rather than execution speed. Reducing the time needed for each project saves companies tons of money.

As far as the execution speed or performance of the program is concerned, we can easily manage it by horizontal scaling, meaning that more servers can be used to reach that level of speed or performance.

In short, \texttt{python} is widely used even when it is somehow slower than other languages because:
\begin{itemize}
	\tightlist
  \item is more productive;
  \item companies can optimize their most expensive resource: employees;
  \item rich set of libraries and frameworks;
  \item large community.
\end{itemize}

\begin{figure}[!ht]
	\centering
	\subfloat[Most used programming languages.\label{subfig-1:used}]{%
		\includegraphics[width=0.7\textwidth]{figures/most_used}
	}\\
	\subfloat[Most loved programming languages.\label{subfig-2:loved}]{%
		\includegraphics[width=0.7\textwidth]{figures/most_loved}
	}\\
	\subfloat[Most dreaded programming languages.\label{subfig-3:dreaded}]{%
	\includegraphics[width=0.7\textwidth]{figures/most_dreaded}
	}
	\caption{Results from 2019 Stack Overflow survey.}
	\label{fig:dummy}
\end{figure}

\section{What is \texttt{python} ?}
\label{what-is-python}

\texttt{Python} is a so called \emph{interpreted language}: it takes some code (a sequence of instructions), reads and executes it. This is different from other programming languages like \texttt{C} or \texttt{C++} which \emph{compile} code into a language that computers can understand directly (\emph{machine language}) (see Fig.~\ref{fig:compiled_vs_interpreted}).

\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{figures/compiled_language.png}
\caption{Interpreted vs compiled language.}
\label{fig:compiled_vs_interpreted}
\end{figure}

As a result, \texttt{python} is essentially an \emph{interactive} programming language, which means you can program and see the results almost at the same time. This is very nice for a faster development since "compilation" time can be quite long (just to give an idea the compilation of our \texttt{C++} financial code takes more than one hour).
However there are drawbacks in term of performance, the \emph{translation} to machine language has to be done in real-time resulting in slower execution times (see Fig.~\ref{fig:compilation}).

\begin{figure}[h]
\centering
\includegraphics[width=0.5\linewidth]{figures/machine_language.png}
\caption{Human readable vs machine code}
\label{fig:compilation}
\end{figure}

In the next Chapters we'll take a quick tour of \texttt{python} and see the main features and characteristics of this programming language. Later on we will see how it can be useful to solve real-world financial problems.

First of all since \texttt{python}, as basically all programs, comes in different version and flavours we need to specify the particular one we are going to use~\cite{python_versions}.
The latest version (at the time I'm writing these pages) is \texttt{3.8.5}, however it is still not difficult to see older versions floating around (e.g. \texttt{2.7}).
This is because there are some big differences between \texttt{python 2.X} and \texttt{python 3.X} which prevent a sizable portion of \texttt{python 2} users to stick with it (consider that moving to \texttt{python 3} would require a large amount of work to adapt big projects).
In conclusion we will concentrate on \textbf{\texttt{python~3.X}}.

\section{\texttt{Python} Basics}
\label{python-basics}

Every language has \emph{keywords}, these are reserved words that have special meaning and tell the computer what to do. The most common one is \texttt{print}: it prints to screen whatever is specified between the parenthesis.

\begin{ipython}
print ("Hello world !")
\end{ipython}
\begin{ioutput}
Hello world !
\end{ioutput}
\begin{ipython}
print ("Welcome")
print ("to")
print ("everybody")
\end{ipython}
\begin{ioutput}
Welcome
to
everybody
\end{ioutput}

Good programming practice recommends to document the code you write (you will soon see that it is surprisingly easy to forget what you wanted to do in your code). In \texttt{python} you can add comments to code starting a line with a hash character (\#).

\begin{ipython}
print ("Ciao") # this is a comment 
\end{ipython}
\begin{ioutput}
Ciao
\end{ioutput}

\subsection{Variables}\label{variables}

A variable is a computer memory location paired with a symbolic name, which contains some quantity of information referred to as a \emph{value} (e.g. a number, a string\ldots). Variables and hence data they contain, can be used, referenced and manipulated throughout a program.
A value is assigned to a variable with the equal operator (=) and printing a variable shows its content. 

\begin{figure}[h]
\centering
\includegraphics[width=0.35\linewidth]{figures/var1.jpeg}\\
\includegraphics[width=0.35\linewidth]{figures/var2.jpeg}
\caption{Graphical representation of a variable.}
\end{figure}

\begin{ipython}
x = 9 
print (x)
\end{ipython}
\begin{ioutput}
9
\end{ioutput}
\begin{ipython}
myphone = "Huawei P10Lite" 
print (myphone)
\end{ipython}
\begin{ioutput}
Huawei P10Lite	
\end{ioutput}

Another very useful keyword is \texttt{type}: it tells which kind of object is stored in a variable.

\begin{ipython}
print (type(x))
print (type(myphone))
\end{ipython}
\begin{ioutput}
<class 'int'>
<class 'str'>
\end{ioutput}

After their definitions \texttt{x} and \texttt{myphone} can be used as aliases for a number and a string and their content manipulated, for example:

\begin{ipython}
print (x + 5)
\end{ipython}
\begin{ioutput}
14
\end{ioutput}

There are rules that limit the variable naming possibilities, in particular they must:
\begin{itemize}
	\tightlist
\item begin with a letter (\texttt{myphone}) or underscore (\texttt{\_myphone});
\item other characters can be letters, numbers or more underscores;
\item variable names are case-sensitive so \texttt{myphone} and \texttt{myPhone} are two distinct variables;
\end{itemize}

\textbf{Keywords, as said, are reserved words and as such cannot be used as variable names (e.g.~\texttt{print, type, for...})}.

To use \textbf{good} variable names (and make your programs clearer and easier to read) always choose meaningful names instead of short names (i.e. \texttt{numberOfCakes} is much better than simply \texttt{n}), try to be consistent with your conventions (e.g.~choose once and for all between \texttt{number\_of\_cakes}, \texttt{numberofcakes} or \texttt{numberOfCakes}), usually begin a variable name with underscore (\_) only for a special case (will see later when this is necessary).

\subsection{Boolean Expressions}\label{boolean-expressions}

Boolean expressions evaluate to \texttt{True} or \texttt{False} only. This type
of expressions usually involve logical or comparison operators like \texttt{or}, \texttt{and}, $\geq$ (greater-than), $\leq$ (less-than)\ldots
The equal-to Boolean operator symbol is a double equal symbols (\texttt{==}), to not be confused with the assignment operator we have seen before made of a single equal symbol (\texttt{=}). With the first we compare two variables, with the second we associate a value to a variable.

Let's see some example. The following expression answers the question is 1 equal to 2:

\begin{ipython}
1 == 2
\end{ipython}
\begin{ioutput}
False
\end{ioutput}

Here another example using the not equal operator (\texttt{!=}):

\begin{ipython}
1 != 2
\end{ipython}
\begin{ioutput}
True
\end{ioutput}
\begin{ipython}
2 < 2
\end{ipython}
\begin{ioutput}
False
\end{ioutput}
\begin{ipython}
2 <= 2 # in this case we allow the numbers to be equal too 
\end{ipython}
\begin{ioutput}
True
\end{ioutput}
\begin{ipython}
print (x)
15 <= x and x <= 20 # this expression could also be written as 15 <= x <= 20
\end{ipython}
\begin{ioutput}
11
False
\end{ioutput}
\begin{ipython}
15 <= x or x <= 20 
\end{ipython}
\begin{ioutput}
True
\end{ioutput}
\begin{ipython}
not (x > 20) # the not keyword negates the following expression 
\end{ipython}
\begin{ioutput}
True
\end{ioutput}

\subsection{String Expressions}\label{string-expressions}

A string is a sequence of characters (letters, digits, spaces, punctuation\ldots). There are many operations that can be performed on strings, like for example concatenate (with \texttt{+} operator), truncate, replace characters\ldots

\begin{ipython}
mystring = "some text with punctuation, spaces and digits 10" 
mystring.replace("s", "z")
\end{ipython}
\begin{ioutput}
'zome text with punctuation, zpacez and digitz 10'
\end{ioutput}

\begin{ipython}
"abc" + "def" # it is possible to concatenate strings with + 
\end{ipython}
\begin{ioutput}
'abcdef'
\end{ioutput}

\begin{ipython}
"The number " + 4 + " is my favourite number"
# this causes an error since we are trying to concatenate a string
# with a number so two different kind of objects
\end{ipython}
\begin{ioutput} 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: must be str, not int
\end{ioutput}

This is the first time we make a mistake so that the \texttt{python} interpreter returns an error. We will 
discuss more deeply errors and their management in a later Section. 
For the moment it is enough to know that to avoid this particular error is possible to \textbf{cast} an object to a 
different type which means to convert an object to a different type. In this case we can \emph{force} the number four to be represented as a string with the \texttt{str()} function:

\begin{ipython}
"The number " + str(4) + " is my favourite number"
\end{ipython}
\begin{ioutput}
'The number 4 is my favourite number'
\end{ioutput}

\begin{ipython}
print (type(3.4)) 
print (type(str(3.4)))
\end{ipython}
\begin{ioutput}
<class 'float'>
<class 'str'>	
\end{ioutput}

In this simple case everything worked fine but type casting is not always possible: for example a number can be converted to a string (e.g. from the integer 4 to the actual symbol "4") but the opposite is not possible (e.g. cannot convert the string "matteo" to a meaningful number). In this second case we can try to use the function \texttt{int()} to convert a string to an integer.

\begin{ipython}
int("matteo")
\end{ipython}
\begin{ioutput}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: 'matteo'
\end{ioutput}

\begin{ipython}
int("4") 
\end{ipython}
\begin{ioutput}
4
\end{ioutput}

\subsubsection{Pretty String Formatting}
In order to get prettier strings than those obtained just concatenating with the + operator, \texttt{python} allows to format text using the following syntax: \texttt{"text \{\} other text \{\}".format(var1, var2)}.
This is not just a mannerism, for example we will see that it may be very useful to represent prices with the correct 
number of significant digits.

With this notation, each \texttt{\{\}} is mapped to the variables listed in the \texttt{format} statement, the optional characters inside the curly brackets can determine the resulting format, for example in the following code \texttt{\{:.1f\}} means that this variable is a float number and that has to be printed with only one digit only after the decimal separator. 

\begin{ipython}
print ("The speed of light is about {:.1f} {}".format(299792.458, "km/s"))	
\end{ipython}
\begin{ioutput}
'The speed of light is about 299792.5 km/s'
\end{ioutput}

In addition \texttt{format} allows for 0-padding of numbers, left or right alignment of text columns and so on.

\subsection{Mathematical Expressions}\label{mathematical-expressions}

Below few examples of the basic mathematical expressions available in \texttt{python}.

\begin{ipython}
print (1 + 2)	
\end{ipython}
\begin{ioutput}
3
\end{ioutput}

\begin{ipython}
print (40 - 5)	
\end{ipython}
\begin{ioutput}
35
\end{ioutput}

\begin{ipython}
print (x * 20) # remember that x is equal to 9
\end{ipython}
\begin{ioutput}
180	
\end{ioutput}

\begin{ipython}
print (x / 4)
\end{ipython}
\begin{ioutput}
2.25
\end{ioutput}

\begin{ipython}
print (type(2.25))
\end{ipython}
\begin{ioutput}
<class 'float'>	
\end{ioutput}

\begin{ipython}
x // 4 # integer division, result will be truncated (no rounding)
       # 11 / 3 = 3.66666, 11 // 3 = 3
\end{ipython}
\begin{ioutput}
2
\end{ioutput}

\begin{ipython}
y = 3
print (x**y) # x to the power of y 	
\end{ipython}
\begin{ioutput}
729
\end{ioutput}

\begin{ipython}
print (3*x + y)	
\end{ipython}
\begin{ioutput}
36	
\end{ioutput}

As an example of variable manipulation let's try to increment \texttt{x} by 1 and save the result again in \texttt{x}.

\begin{ipython}
print (x)
x = x + 1
print (x)	
\end{ipython}
\begin{ioutput}
15
16
\end{ioutput}

Sometimes the increment of a variable plus the assignment to the same variable is written 
with a more compact syntax \texttt{x += 1} (this is also true for other operators e.g. \texttt{x *= 2}).

More complex mathematical functions are not directly available, let's see for example the logarithm:

\begin{ipython}
log(3)
\end{ipython}
\begin{ioutput}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'log' is not defined
\end{ioutput}

\section{Modules}\label{modules}

One very important feature of each language is the ability to reuse code among 
different programs, e.g. imagine how awful would be if you had to re-implement every time 
you need it a function to compute the logarithm.
Usually there are mechanisms that allow to collect useful routines in \emph{packages} 
(or \emph{libraries}, or \emph{modules}) so that later they can be called and used by any 
program may need them.

These collections of utilities in \texttt{python} are called \emph{modules} and each installation 
of this language brings with it a standard set of them. If you need more functionality, you can 
download more modules from the web (there are zillions out there~\cite{modules}, see Fig.~\ref{fig:fancy_module})
or if you are 
not satisfied with what you found you can write your own (which is one of the goals of this course).

Some examples of useful modules we are going to use are:

\begin{itemize}
\tightlist
\item
  Numpy - which provides matrix algebra functionality and much more;
\item
  Scipy - which provides a whole series of scientific computing
  functions;
\item
  Pandas - which provides tools for manipulating time series or data-set
  in general;
\item
  Matplotlib - for plotting graphs;
\item
  Jupyter - for notebooks like the one used in classroom.
\end{itemize}

\begin{figure}
\centering
\includegraphics[width=0.5\linewidth]{figures/python.png}
\caption{\texttt{Python} has many modules for download on the web\ldots}
\label{fig:fancy_module}
\end{figure}

In Chapters~\ref{sec:datetime} and~\ref{sec:datamanip} we take a closer look at three modules which are particularly 
useful in financial analysis.

In order to load a module in a \texttt{python} program you have to use the \texttt{import} keyword. 
To inspect a module (to understand which are its functionalities) it can be used either 
\texttt{help} and \texttt{dir} keywords: the first writes a help message which usually describes 
the functionalities of the module, the latter systematically lists all the available functions of a module.
\textbf{In order to access a function of a module you have to use the dot (\texttt{.}) operator: 
\texttt{module-name.function-name}.}

The \texttt{math} module implements the most common mathematical functions, let's see an example. 

\begin{ipython}
import math
dir(math)
\end{ipython}
\begin{ioutput}
['\_\_doc\_\_',
 '\_\_loader\_\_',
 '\_\_name\_\_',
 '\_\_package\_\_',
 '\_\_spec\_\_',
 'acos',
 'acosh',
 'asin',
 'asinh',
 'atan',
 'atan2',
 'atanh',
 'ceil',
 'copysign',
 'cos',
 'cosh',
...	
\end{ioutput}

\begin{ipython}
help(math)
\end{ipython}
\begin{ioutput}
Help on module math:

NAME
math

MODULE REFERENCE
https://docs.python.org/3.6/library/math

The following documentation is automatically generated from the Python
source files.  It may be incomplete, incorrect or include features that
are considered implementation detail and may vary between Python
implementations.  When in doubt, consult the module reference at the
location listed above.

DESCRIPTION
This module is always available.  It provides access to the
mathematical functions defined by the C standard.

FUNCTIONS
acos(...)
acos(x)

Return the arc cosine (measured in radians) of x.
...
\end{ioutput}

\begin{ipython}
print (math.log(3))
\end{ipython}
\begin{ioutput}
1.0986122886681098	
\end{ioutput}

\begin{ipython}
print (math.exp(3))
\end{ipython}
\begin{ioutput}
20.085536923187668	
\end{ioutput}

\begin{ipython}
print (type(math.log)) # yet another type: builtin function
print (type(math.log(3)))
\end{ipython}
\begin{ioutput}
<class 'builtin\_function\_or\_method'>
<class 'float'>	
\end{ioutput}

If you want to avoid to type \texttt{math.} every time you compute a logarithm or an exponential, 
it is possible to import only the needed functions from the module using the following syntax:

\begin{ipython}
from math import log, exp

print (log(3))
print (exp(3))
\end{ipython}
\begin{ioutput}
1.0986122886681098
20.085536923187668	
\end{ioutput}

As an example let's compute the interest rate \(r\) that produces a return \(R\) of 
\euro 11000 when investing \euro 10000 for 2 years:

\[R = N\mathrm{e}^{r\tau} \implies r = \frac{1}{\tau} \mathrm{log}(\frac{R}{N})\]

\begin{ipython}
rate = (1/2)*log(11000/10000)
print (rate)
\end{ipython}
\begin{ioutput}
0.04765508990216247	
\end{ioutput}

\section{Indented Blocks and Conditionals}
\label{indented-blocks-and-the-ttifelse-statement}

Unlike other languages which uses parenthesis to isolate blocks of code \texttt{python} uses \emph{indentation}. A first example of this peculiarity is given by conditional statements (i.e. \texttt{if/elif/else}). Such commands allow to dynamically run different blocks of code based on conditions. For example in the following we print different statements according to the value of \texttt{x}, note that the block of code to be run according each condition is shifted (i.e. indented) with respect to the rest of the code:

\begin{ipython}
print (x)
if x == 1:
	print ("This will not be printed")
elif x == 15:
	print ("This will not be printed either")
else:
	print ("This *will* be printed")
\end{ipython}
\begin{ioutput}
16
This *will* be printed	
\end{ioutput}

If by mistake the indentation of a block is missing an exception is raised:

\begin{ipython}
if x == 1:
    print ("This will not be printed")
elif x == 15:
    print ("This will not be printed either")
else:
   print ("This *will* be printed")
\end{ipython}
\begin{ioutput}
  File "<stdin>", line 6
    print ("This will not be printed")
        ^
IndentationError: expected an indented block
\end{ioutput}

Below another example:
\begin{ipython}
if x != 1:
    print ("x does not equal 1")
\end{ipython}
\begin{ioutput}
x does not equal to 1	
\end{ioutput}

Just for comparison this is the same code written in \texttt{C++}:

\begin{lstlisting}[style=mycpp]
if (x == 1) {
 std::cout << "This will not be printed" << std::endl;
} else if (x == 15) {
     std::cout << "This will not be printed either" << std::endl;
} else {
   std::cout << "This *will* be printed" << std::endl;
}
\end{lstlisting}

Notice how indentation doesn't matter at all here since the blocks are enclosed and 
defined by the brackets.

\section{Loops}\label{loops}

Another very important feature of a language is the ability to repeatedly run the same 
block of code many times. This is called looping and in \texttt{python} can be done
 with \texttt{for} or \texttt{while} keywords.

\subsection{\texttt{for}}\label{for}

In a \texttt{for} loop we specify the set (or interval) over which we want to loop and a 
variable will assume all the values in that set (or interval). For example let's assume we 
want to print all the numbers between 25 and 30 (excluded) 

\begin{ipython}
for i in range(25, 30):
    print (i)	
\end{ipython}
\begin{ioutput}
25
26
27
28
29	
\end{ioutput}
\noindent
where the keyword \texttt{range} returns the list of integers between the specified limits, 
if the first limit is not specified 0 is assumed.
At each cycle of the loop the variable \texttt{i} takes one of the values between
25 and 29. 

With \texttt{range} it is also possible to specify the step, so that the loop can jump every 2 units or to go in descending order:

\begin{ipython}
for i in range(30, 25, -1):
    print (i)	
\end{ipython}
\begin{ioutput}
30
29
28
27
26	
\end{ioutput}

If it is needed to skip values in the loop the \texttt{continue} keyword can be used; 
in the code below 5 is actually not printed since it has been skipped by the condition executing 
\texttt{continue}:

\begin{ipython}
for i in range(10):
    if i == 5:
        continue
    print (i)	
\end{ipython}
\begin{ioutput}
0
1
2
3
4
6
7
8
9	
\end{ioutput}

Instead of using \texttt{range} it is possible to specify directly the set of looping values:

\begin{ipython}
for i in (4, 6, 10, 20):
    print (i)	
\end{ipython}
\begin{ioutput}
4
6
10
20	
\end{ioutput}

Finally looping on a string actually means to loop on each single character:
 
\begin{ipython}
phrase = "how to loop over a string"
for c in phrase:
    print(c) 	
\end{ipython}
\begin{ioutput}
h
o
w

t
o

l
o
o
p

o
v
e
r

a

s
t
r
i
n
g
\end{ioutput}
 
\subsection{\texttt{while}}\label{while}

The \texttt{while} statement repeats the same block of code until a condition is met.
For example in the following code, the block is run until \texttt{x} squared is less than 50.
At the beginning \texttt{x=1} and at each iteration we increment it by 1 "while" the condition 
is \texttt{True} (it should stop when \texttt{x}$\gt 7$ because it is the last squared lower than 50):

\begin{ipython}
x = 1
while x**2 < 50:
    print (x)
    x += 1	
\end{ipython}
\begin{ioutput}
1
2
3
4
5
6
7	
\end{ioutput}

It is possible to exit prematurely from a \texttt{while} loop using the \texttt{break} keyword. 
In this case the while-condition is simply \texttt{True} so the code would run forever 
unless we set an exit strategy.

\begin{ipython}
x = 1
while True:
    if x**2 > 50:
        break
    print (x)
    x += 1	
\end{ipython}
\begin{ioutput}
1
2
3
4
5
6
7	
\end{ioutput}

\section{Errors and Exceptions}
In the previous Sections we have already found a couple of examples with errors.
Here we are going to look deeply what they are and how can be managed.
There are (at least) two distinguishable kinds of errors:  \emph{syntax errors} and \emph{exceptions}.

\subsection{Syntax Errors}
Syntax errors are perhaps the most common kind of complaint you get while you are still learning \texttt{python}.

\begin{ipython}
while True
    print ("Hello world")
\end{ipython}
\begin{ioutput}
  File "<stdin>", line 1
    while True print('Hello world')
               ^
SyntaxError: invalid syntax
\end{ioutput}

The parser repeats the offending line and displays a little "arrow" 
pointing at the earliest point in the line where the error was detected. 
The error is caused by the token preceding the arrow: in the example, 
the error is detected at the function \texttt{print()}, 
since a colon (\texttt{:}) is missing before it. 
File name and line number are printed so you know where to look in case the input came from a script.

\subsection{Exceptions}
Even if a statement or expression is syntactically correct, it may cause 
an error when an attempt is made to execute it. 
Errors detected during execution are called exceptions and are not unconditionally fatal.
Most exceptions are not handled by programs and result in error 
messages as shown here:

\begin{ipython}
10 * (1/0)
\end{ipython}
\begin{ioutput}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
\end{ioutput}

\begin{ipython}
4 + spam*3
\end{ipython}
\begin{ioutput}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'spam' is not defined
\end{ioutput}

\begin{ipython}
'2' + 2
\end{ipython}
\begin{ioutput}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: must be str, not int
\end{ioutput}

The last line of the error message indicates what happened. Exceptions come in different types, and the type is printed as part of the message: the types in the example are \texttt{ZeroDivisionError}, \texttt{NameError} and \texttt{TypeError}. The string printed as the exception type is the name of the exception that occurred. The rest of the line provides detail based on the type of exception and what caused it.

The preceding part of the error message shows the context where the exception occurred, in the form of a stack traceback listing source lines.

\subsection{Handling Exceptions}
It is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (e.g. using Control-C); note that a user-generated interruption is signaled by raising the \texttt{KeyboardInterrupt} exception.

\begin{ipython}
while True: 
    try:
        x = int(input("Please enter a number: ")) 
        break
    except ValueError:
        print("Oops! That was no valid number. Try again...")
\end{ipython}
\begin{ioutput}
Please enter a number: pippo
Oops!  That was no valid number.  Try again...

Please enter a number:
\end{ioutput}

The \texttt{try} statement works as follows: first, the try clause is executed.
If no exception occurs, the except clause is skipped and 
execution of the \texttt{try} statement is finished.

If an exception occurs during execution of the try clause, 
the rest of the clause is skipped. Then if its type matches the 
exception named after the \texttt{except} keyword, the corresponding except clause 
is executed, and then execution continues after the \texttt{try} statement.

If an exception occurs which does not match the exception named in the 
except clause, it is passed on to outer \texttt{try} statements; 
if no handler is found, it is an un-handled exception and execution stops 
with a message as shown above.

A \texttt{try} statement may have more than one except clause, 
to specify handlers for different exceptions. At most one handler will be
executed. Handlers only handle exceptions that occur in the corresponding 
try clause, not in other handlers of the same \texttt{try} statement.

\begin{ipython}
    except RuntimeError, TypeError, NameError:
        pass	
\end{ipython}

The last except clause may omit the exception name(s), to serve as a wildcard.
Use this with extreme caution, since it is easy to mask a real programming 
error in this way! 

\begin{ipython}
import sys 

try:
    with open('myfile.txt') as f: 
        s = f.readline()
        i = int(s.strip()) 
except OSError as err:
    print("OS error: {0}".format(err)) 
except ValueError:
    print("Could not convert data to an integer.") 
except:
    print("Unexpected error:", sys.exc_info()[0])
\end{ipython}
\begin{ioutput}
OS error: [Errno 2] No such file or directory: 'myfile.txt'	
\end{ioutput}

\section{Assertions}
\texttt{Python} has a useful command called \texttt{assert} which can be used for checking that a given condition is satisfied, and it raises an exception if this is not true. This is clearly very important when debugging some code, it helps in searching for mistakes in the logic of an algorithm.

Below few examples of its usage. The following line does not cause an error, in fact it does nothing since 1 is lower than 2, hence the condition is met:

\lstinline[language=iPython]|assert 1 < 2|

\noindent
The next one instead causes an error (the condition is evaluated to false): 

\lstinline[language=iPython]|assert 1 > 2|

\noindent
\texttt{assert} can take a second optional argument with a message to display in case of failure.

\lstinline[language=iPython]|assert 1 > 2, "Two is greater than one"|

\section*{Exercises}
\input{intro_ex_text}

\begin{thebibliography}{9}
%\bibitem{survey2019} StackOverflow \emph{The TEXbook}, Addison-Wesley, Reading,Massachusetts, second edition, 1984,
\bibitem{survey2019} \href{https://insights.stackoverflow.com/survey/2019}{\emph{Stack Overflow 2019 survey}}, Stack Overflow, 2019 [Online]
\bibitem{python_versions} \href{https://www.python.org/downloads/}{\emph{Python Distribution Versions}}, \texttt{python.org} [Online]
\bibitem{learn_python} \href{https://www.learnpython.org/it/}{\emph{Learning Python}}, \texttt{learnpython.org} [Online]
\bibitem{freecamp} \href{https://www.youtube.com/watch?v=8DvywoWv6fI}{\emph{Python Basics Tutorial}}, \texttt{freeCodeCamp.org} [Online]
\bibitem{modules} \href{https://docs.python.org/3/py-modindex.html}{\emph{Complete list of Python 3 modules}} [Online]
\end{thebibliography}
