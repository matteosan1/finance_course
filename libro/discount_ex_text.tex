\cprotEnv\begin{question}
\label{ex:yield_discount}
Using the \texttt{DiscountCurve} class, implemented in this Chapter, build a curve with the given inputs (pillar dates and yields)

\begin{ipython}
today = date(2020, 10, 15)
dates = [date(2021, 1, 15), date(2021, 4, 15), date(2021, 7, 15),
         date(2021, 10, 15), date(2022, 10, 15), date(2023, 10, 15),
         date(2024, 10, 15), date(2025, 10, 15), date(2026, 10, 15),
         date(2027, 10, 15), date(2028, 10, 15), date(2029, 10, 15),
         date(2030, 10, 15), date(2031, 10, 15), date(2032, 10, 15),
         date(2033, 10, 15), date(2034, 10, 15), date(2035, 10, 15),
         date(2036, 10, 15), date(2037, 10, 15), date(2038, 10, 15),
         date(2039, 10, 15), date(2040, 10, 15), date(2041, 10, 15),
         date(2042, 10, 15), date(2043, 10, 15), date(2044, 10, 15),
         date(2045, 10, 15), date(2046, 10, 15), date(2047, 10, 15),
         date(2048, 10, 15), date(2049, 10, 15), date(2050, 10, 15)]
yields = [-0.652548, -0.687966, -0.718319, -0.744011, -0.807362,
          -0.822144, -0.803715, -0.763496, -0.709892, -0.649001,
          -0.585169, -0.521425, -0.459808, -0.401628, -0.347657,
          -0.298283, -0.253620, -0.213593, -0.178005, -0.146578,
          -0.118993, -0.094911, -0.073989, -0.055896, -0.040317,
          -0.026957, -0.015546, -0.005840,  0.002383,  0.009320,
           0.015145,  0.020013,  0.024059]
\end{ipython}
\noindent
By interpolation, find the 18m yield, then draw the yield curve. Finally instantiate a \texttt{DiscountCurve} object, draw the curve and discount factors at the following dates
\begin{ipython}
df_dates = [date(2025, 4, 15), date(2031, 4, 15)]
\end{ipython}
\end{question}

\cprotEnv\begin{solution}
To interpolate the given yields the \texttt{interp} function can be used. Before doing that it is necessary to convert the dates into numbers (i.e. the difference between the actual date and "today").
\begin{ipython}
from dateutil.relativedelta import relativedelta
import numpy as np

num_dates = [(d-today).days for d in dates]
target = (today+relativedelta(months=18)-today).days
print (np.interp(target, num_dates, yields))
\end{ipython}
\begin{ioutput}
-0.7755997178082192
\end{ioutput}

Figure~\ref{fig:ex_yield} shows the yield curve and the interpolated point of the 18m yield.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.7\linewidth]{figures/ex_yield}
\caption{Yield curve resulting from the exercise inputs.}
\label{fig:ex_yield}
\end{figure}

To construct the discount curve first it is necessary to define the discount factors from the yields. Then you need to instantiate a \texttt{DiscountCurve} object with the mandatory inputs and call the \texttt{df} method to compute the discount factors at the required dates.
\begin{ipython}
from finmarkets import DiscountCurve

dfs = []
for i, d in enumerate(dates):
    dfs.append(np.exp(-yields[i]/100*((d-today).days/365)))
    
dc = DiscountCurve(today, dates, dfs)
print (dc.df(date(2025, 4, 15)))
print (dc.df(date(2031, 4, 15)))
\end{ipython}
\begin{ioutput}
1.035800870152254
1.0461387588227613
\end{ioutput}

Figure~\ref{fig:ex_discount} shows the discount curve and the interpolated discount factors.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.7\linewidth]{figures/ex_discount}
\caption{Discount curve resulting from the exercise inputs.}
\label{fig:ex_discount}
\end{figure}
\end{solution}

%\cprotEnv\begin{question}
%Calculate the forward interest for the period from six months (180/360) from now to nine months (270/360) from now if the six month rate is 4.50\% p.a. and the nine month rate is 4.25\% p.a.
%\end{question}
%
%\cprotEnv\begin{solution}
%FV
%FV
%6
%9
%1 +0.045* 180/360 1025
%1 +0.0425 *270-360 10525
%
%360/90 *1.03188/1.02250 = 0.0367 = 3.67
%\end{solution}

\begin{question}
Given the same inputs of Exercise~\ref{ex:yield_discount} and using the \texttt{ForwardRateCurve} class compute the 10y forward rate in 1y from today. 
\end{question}

\cprotEnv\begin{solution}
\begin{ipython}
from finmarkets import ForwardRateCurve

fc = ForwardRateCurve(today, dates, yields)
print ("{:.4f}%".format(fc.forward_rate(date(2021, 10, 15), date(2031, 10, 15))/100))
\end{ipython}
\begin{ioutput}
-0.0037%
\end{ioutput}
\end{solution}

%\texttt{Python} has a useful command called \texttt{assert} which can be used for checking that a given condition is satisfied, and raising an error if the condition is not satisfied.
%
%The following line does not cause an error, in fact it does nothing since 1 is lower than 2, hence the condition is met.
%
%\lstinline[language=iPython]|assert 1 < 2|
%
%\noindent
%This causes an error (the condition is evaluated to false). 
%
%\lstinline[language=iPython]|assert 1 > 2|
%
%\noindent
%\texttt{assert} can take a second argument with a message to display in case of failure.
%
%\lstinline[language=iPython]|assert 1 > 2, "Two is greater than one"|
%
%\noindent
%Now takes the \texttt{df} function from the Chapter on Discounting and modify it by adding some assertions to check that:
%
%\begin{itemize}
%\item the pillar date list contains at least 2 elements;
%\item the pillar date list has the same length as the discount factor one;
%\item the first pillar date is equal to the today's date;
%\item the value date (first argument \texttt{d}) is greater or equal to the first pillar date and also less than or equal to the last pillar date.
%\end{itemize}
%
%Then try using the function with some invalid data to make sure that your assertions are correctly checking the desired conditions
%\end{question}
%
%\cprotEnv\begin{solution}
%\begin{ipython}
%# import modules and objects that we need
%from datetime import date
%import numpy
%import math
%
%today_date = date(2017, 10, 1)
%pillar_dates = [date(2017, 10, 1),
%date(2018, 10, 1),
%date(2019, 10, 1)]
%discount_factors = [1.0, 0.95, 0.8]
%
%def df(d, observation_date, pillar_dates, discount_factors):
%    ############## CHECKS ################
%    assert len(pillar_dates) >= 2, " need at least 2 pillar dates"
%    assert len(pillar_dates) == len(discount_factors), \
%        "number of pillar dates should be equal to \
%         the number of pillar discount factors"
%    assert observation_date == pillar_dates[0], \
%        "first pillar date should be the observation date"
%    assert pillar_dates[0] <= d <= pillar_dates[-1], \
%        "Invalid value date %s" % (d)
%    ############## END OF CHECKS ################
%    log_discount_factors = []
%    for discount_factor in discount_factors:
%        log_discount_factors.append(math.log(discount_factor))
%    pillar_days = []
%    for pillar_date in pillar_dates:
%        pillar_days.append((pillar_date - observation_date).days)
%    d_days = (d - observation_date).days
%    interpolated_log_discount_factor = \
%        numpy.interp(d_days, pillar_days, log_discount_factors)
%    return math.exp(interpolated_log_discount_factor)
%
%df(date(2019, 1, 1), today_date, pillar_dates, discount_factors)
%\end{ipython}
%\begin{ioutput}
%0.9097285910181567
%\end{ioutput}
%\end{solution}

%\begin{question}
%Copy into the file \texttt{finmarkets.py} the function used to compute Black Scholes formula used in Ex.~\ref{ex:BS2}. This is another utility for our financial library. Then repeat Ex.~\ref{ex:BS2} now using the version of the Black and Scholes formula in the \texttt{finmarkets} module.
%\end{question}
%
%\begin{solution}
%\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=cellbackground, colframe=cellborder]
%\begin{Verbatim}[commandchars=\\\{\}]
%\PY{k}{import} \PY{n}{finmarkets}
%        
%\PY{n}{s} \PY{o}{=} \PY{l+m+mi}{800}
%\PY{c+c1}{\PYZsh{} strikes expressed as \PYZpc{} of spot price}
%\PY{n}{moneyness} \PY{o}{=} \PY{p}{[} \PY{l+m+mf}{0.5}\PY{p}{,} \PY{l+m+mf}{0.75}\PY{p}{,} \PY{l+m+mf}{0.825}\PY{p}{,} \PYZbs{}
%             \PY{l+m+mf}{1.0}\PY{p}{,} \PY{l+m+mf}{1.125}\PY{p}{,} \PY{l+m+mf}{1.25}\PY{p}{,} \PY{l+m+mf}{1.5} \PY{p}{]}
%\PY{n}{vol} \PY{o}{=} \PY{l+m+mf}{0.3}
%\PY{n}{ttm} \PY{o}{=} \PY{l+m+mf}{0.75}
%\PY{n}{r} \PY{o}{=} \PY{l+m+mf}{0.005}
%
%\PY{n}{result} \PY{o}{=} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}
%\PY{k}{for} \PY{n}{m} \PY{o+ow}{in} \PY{n}{moneyness}\PY{p}{:}
%    \PY{n}{result}\PY{p}{[}\PY{n}{s}\PY{o}{*}\PY{n}{m}\PY{p}{]} \PY{o}{=} \PY{n}{finmarkets.call}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{m}\PY{o}{*}\PY{n}{s}\PY{p}{,} \PY{n}{r}\PY{p}{,} \PY{n}{vol}\PY{p}{,} \PY{n}{ttm}\PY{p}{)}
%\PY{n}{result}
%
%\{400.0: 401.66074527896365,
%  600.0: 213.9883852521275,
%  660.0: 166.85957363897393,
%  800.0: 84.03697017660357,
%  900.0: 47.61880394696229,
%  1000.0: 25.632722952585738,
%  1200.0: 6.655275227771156\}
%\end{Verbatim}
%\end{tcolorbox}
%\end{solution}

