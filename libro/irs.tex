\chapter{Interest Rate Swaps and Swaptions}
\label{interest-rate-swaps-and-swaptions}

In Chapter~\ref{sec:swaps-and-bootstrapping} we introduced a particular type of swap, the Overnight Index Swap. Here we describe a more general Interest Rate Swap and see how it can underlying a swaption, the analogous of the European options for interest rate market.

\section{Interest Rate Swaps}\label{interest-rate-swaps}

Interest rate swaps (IRS) consist of two legs: a floating and a fixed. The contract parameters are:

\begin{itemize}
\tightlist
\item
  start date \(d_0\);
\item
  notional \(N\);
\item
  fixed rate \(K\);
\item
  floating rate tenor (months);
\item
  maturity (years).
\end{itemize}

The floating leg pays the reference LIBOR fixing at a frequency equal to the tenor of the floating rate, so for example an IRS on a 3-month LIBOR will pay a floating coupon every three months, an IRS on 6-month EURIBOR pays the floating coupon every six months and so on.

The fixed leg pays a predetermined cash flow at annual frequency, regardless of the tenor of the underlying floating rate (for simplicity we will only consider swaps with maturities which are multiples of 1 year).

Before going into the details of the valuation of IRSs, we need to modify the \texttt{generate\_dates} function in \texttt{finmarkets} module to generate the payment dates for both the fixed and floating legs. 
The modification consists of the addition of a new input parameter, the tenor, which was previously fixed to 12 months.

\begin{ipython}
from datetime import date
from dateutil.relativedelta import relativedelta

def generate_dates(start_date, n_months, tenor_months=12):
    dates = []
    for n in range(0, n_months, tenor_months):
        dates.append(start_date + relativedelta(months=n))
    dates.append(start_date + relativedelta(months=n_months))
    return dates
    
generate_dates(date.today(), 16, 3)
\end{ipython}
\begin{ioutput}
[datetime.date(2020, 10, 15),
 datetime.date(2021, 1, 15),
 datetime.date(2021, 4, 15),
 datetime.date(2021, 7, 15),
 datetime.date(2021, 10, 15),
 datetime.date(2022, 1, 15),
 datetime.date(2022, 2, 15)]
\end{ioutput}
Having set the default value of \texttt{tenor\_months} to 12 allows the new function to be \emph{backward-compatible}, meaning that old code based on its previous version will keep working, being written on the assumption of a fixed tenor of twelve months. 
       
Using this function and the contract parameters we will be able to determine a sequence of payment dates for each leg of the IRS.

\subsection{IRS Valuation}
\label{irs-valuation}

Let \(d_0=d_0^{\mathrm{fixed}},...,d_p^{\mathrm{fixed}}\) be the fixed leg payment dates and \(d_0=d_0^{\mathrm{float}},...,d_p^{\mathrm{float}}\) be the floating leg payment dates and let's use the following notation:

\begin{itemize}
\tightlist
\item
  \(d\) the pricing date;
\item
  \(D(d, d')\) the discount factor observed in date \(d\) for the value date \(d'\);
\item
  \(F(d, d', d'')\) the forward rate observed in date \(d\) for the period \([d', d'']\); 
  \item the tenor is \(\tau = d'' - d'\).
\end{itemize}
The NPV of the fixed leg is calculated as follows:

\begin{equation}
\mathrm{NPV}_{\mathrm{fixed}}(d, K) = N\cdot K\cdot\sum_{i=1}^{n}D(d, d_{i}^{\mathrm{fixed}})\end{equation}
while the NPV of the floating leg is:

\begin{equation}\mathrm{NPV}_{\mathrm{float}}(d) = N\cdot\sum_{i=1}^{m}F(d, d_{j-1}^{\mathrm{float}}, d_{j}^{\mathrm{float}}) \cdot \frac{d_{j}^{\mathrm{float}}-d_{j-1}^{\mathrm{float}}}{360}
\cdot D(d, d_{i}^{\mathrm{float}})\end{equation}

Therefore the NPV of the swap (seen from the point of view of the counter-party which receives the floating leg) is

\begin{equation}\mathrm{NPV}(d, K) = \mathrm{NPV}_{\mathrm{float}}(d) - \mathrm{NPV}_{\mathrm{fixed}}(d, K)\end{equation}

For reasons which will become apparent later, it's actually more convenient to express the NPV of an IRS as a function of the fair value fixed rate $S$ of the IRS, also known as the \textbf{swap rate}, which is the value of $K$ which makes \(\mathrm{NPV}(d)=0\). On the basis of the previous expressions, we can easily calculate $S$ as

\begin{equation}
\begin{gathered}
\mathrm{NPV}_{\mathrm{fixed}}(d, S) = \mathrm{NPV}_{\mathrm{float}}(d)\\
N\cdot S\cdot\sum_{i=1}^{n}D(d, d_{i}^{\mathrm{fixed}}) = N\cdot\sum_{i=1}^{m}F(d, d_{j-1}^{\mathrm{float}}, d_{j}^{\mathrm{float}}) \cdot \frac{d_{j}^{\mathrm{float}}-d_{j-1}^{\mathrm{float}}}{360} \cdot D(d, d_{i}^{\mathrm{float}})\\
S=\frac{\sum_{i=1}^{m}F(d, d_{j-1}^{\mathrm{float}}, d_{j}^{\mathrm{float}}) \cdot \frac{d_{j}^{\mathrm{float}}-d_{j-1}^{\mathrm{float}}}{360}
\cdot D(d, d_{i}^{\mathrm{float}})}{\sum_{i=1}^{n}D(d, d_i^{\mathrm{fixed}})}
\end{gathered}
\end{equation}

Once we have calculated \(S\), we can express the \(\mathrm{NPV}\) of an IRS as follows:

\begin{equation}
\begin{split}&\mathrm{NPV}(d, K) = \mathrm{NPV}_{\mathrm{float}}(d) - \mathrm{NPV}_{\mathrm{fixed}}(d, K) = \\ 
&= \underbrace{\mathrm{NPV}_{\mathrm{float}}(d) - \mathrm{NPV}_{\mathrm{fixed}}(d, S)}_{\mathrm{=\;0}} + \mathrm{NPV}_{\mathrm{fixed}}(d, S) - \mathrm{NPV}_{\mathrm{fixed}}(d, K) \\ 
& = N\cdot(S-K)\cdot\underbrace{\sum_{i=1}^{n}D(d, d_{i}^{\mathrm{fixed}})}_{\mathrm{'annuity'}}
\end{split}
\end{equation}

For convenience the relevant inputs that will be used later (LIBOR and discount curve definitions) have been saved in the files  \href{https://github.com/matteosan1/finance_course/raw/develop/libro/input_files/libor_curve.xlsx}{libor\_curve.xlsx} and \href{https://github.com/matteosan1/finance_course/raw/develop/libro/input_files/discount_curve.xlsx}{discount\_curve.xlsx} respectively.

\begin{ipython}
import pandas as pd
from datetime import date
from finmarkets import DiscountCurve, ForwardRateCurve, generate_dates

pricing_date = date(2020, 10, 20)
discount_data = pd.read_excel('discount_curve.xlsx')
libor_data = pd.read_excel('libor_curve.xlsx')
dc = DiscountCurve(pricing_date,
                   discount_data['pillar'].dt.date.tolist(),
                   discount_data['discount_factor'].tolist())
lc = ForwardRateCurve(pricing_date, 
                      libor_data['date'].dt.date.tolist(),
                      libor_data['rate'].tolist())

print (dc.df(date(2021, 1, 1)))
print (lc.forward_rate(pricing_date, date(2021, 7, 2)))
\end{ipython}
\begin{ioutput}
1.0039420028660369
0.010070410958904109
\end{ioutput}

Now a \texttt{InterestRateSwap} class can be implemented to valuate IRS contracts.

\begin{ipython}
class InterestRateSwap:
    def __init__(self, start_date, notional,
                 fixed_rate, tenor_months, maturity_years):
        self.start_date = start_date
        self.notional = notional
        self.fixed_rate = fixed_rate
        self.fixed_leg_dates = \
            generate_swap_dates(start_date, 12 * maturity_years)
        self.floating_leg_dates = \
            generate_swap_dates(start_date, 12 * maturity_years, tenor_months)
    
    def annuity(self, discount_curve, pricing_date=None):
        if pricing_date is None:
            pricing_date = self.start_date
        a = 0
        for i in range(1, len(self.fixed_leg_dates)):
            if pricing_date > self.fixed_leg_dates[i]:
                continue
            a += discount_curve.df(self.fixed_leg_dates[i])
        return a

    def swap_rate(self, discount_curve, libor_curve, pricing_date=None):
        if pricing_date is None:
            pricing_date = self.start_date
        s = 0
        for j in range(1, len(self.floating_leg_dates)):
            F = libor_curve.forward_rate(pricing_date, self.floating_leg_dates[j-1])
            tau = (self.floating_leg_dates[j] - \
                self.floating_leg_dates[j-1]).days / 360 
            P = discount_curve.df(self.floating_leg_dates[j])
            s += F * tau * P
        return s / self.annuity(discount_curve)

    def npv(self, discount_curve, libor_curve, pricing_date=None):
        if pricing_date is None:
            pricing_date = self.start_date
        S = self.swap_rate(discount_curve, libor_curve, pricing_date)
        A = self.annuity(discount_curve, pricing_date)
        return self.notional * (S - self.fixed_rate) * A
\end{ipython}

\begin{finmarkets}
This class goes into \texttt{finmarkets} financial module to manage Interest Rate Swaps.
\end{finmarkets}
Let's test our class instantiating an IRS with 1~M notional, fixed rate of 5\%, 6 month tenor and a maturity of 4 years; discount and LIBOR curves are the same as before.

\begin{ipython}
pricing_date = date.today()
start_date = date.today() + relativedelta(months=1)
irs = InterestRateSwap(pricing_date, start_date, 
                       1e6, 0.05, 6, 4)
print ("{:.2f} EUR".format(irs.npv(dc, lc)))
\end{ipython}
\begin{ioutput}
-158942.33 EUR
\end{ioutput}

\textbf{Can you guess what could be the \textbf{swap rate} given that the NPV obtained above ?}

Since we are looking at this contracts from the point of view of the receiver of the floating leg and that the swap rate is the rate that makes the total NPV equal to 0, the NPV of the floating leg has to be increased to balance the value of the fixed leg so the swap rate will be lower than the fixed rate of the IRS.

\begin{ipython}
print ("{:.5f}".format(irs.swap_rate(dc, lc)))
\end{ipython}
\begin{ioutput}
0.01055
\end{ioutput}
    
To check if we have computed correctly the swap rate we can instantiate a new IRS with fixed rate equal to the just calculated swap rate and print its NPV, it should come very close to 0.

\begin{ipython}
irs2 = InterestRateSwap(start_date, 1e6, 0.01055, 6, 4)
print ("{:.2f} EUR".format(irs2.npv(dc, lc)))
\end{ipython}
\begin{ioutput}
14.84 EUR
\end{ioutput}

The result is not exactly zero since in the calculation it has been used a rounded version of the swap rate, you can check it by replacing 0.01055 with the exact value coming from the previous evaluation. 
   
\section{Inheritance Again}
Now that we have introduced two kinds of swap we can try to make an alternative implementation of their classes, this time using inheritance.

The base (or parent) class will be \texttt{GenericSwap} and it will implement just the constructor taking in input the basic data characterizing a swap: notional, maturity, tenor and rate of the fixed leg. We will slightly modify the implementation of the \texttt{OvernightIndexSwap} class since now the payment dates will be computed directly in the constructor of \texttt{GenericSwap}.

\begin{ipython}
class GenericSwap:
    def __init__(self, start_date, notional,
                 fixed_rate, maturity_years, tenor_months=12):
        self.start_date = start_date        
        self.notional = notional
        self.fixed_rate = fixed_rate
        self.fixed_leg_dates = \
            generate_swap_dates(start_date, 12 * maturity_years)
        self.floating_leg_dates = \
            generate_swap_dates(start_date, 12 * maturity_years, tenor_months)
        self.maturity = maturity_years

    def npv(self):
        print ("{} doesn't implement npv method.".format(self.__name__))

class OvernightIndexSwap(GenericSwap):
    def npv_floating_leg(self, discount_curve):
        return self.notional * (discount_curve.df(self.floating_leg_dates[0]) -
            discount_curve.df(self.floating_leg_dates[-1]))

    def npv_fixed_leg(self, discount_curve):
        npv = 0
        for i in range(1, len(self.fixed_leg_dates)):
            start_date = self.fixed_leg_dates[i-1]
            end_date = self.fixed_leg_dates[i]
            tau = (end_date - start_date).days / 360
            df = discount_curve.df(end_date)
            npv += df * tau 
        return self.notional * self.fixed_rate * npv

    def npv(self, discount_curve):
        float_npv = self.npv_floating_leg(discount_curve)
        fixed_npv = self.npv_fixed_leg(discount_curve)
        return float_npv - fixed_npv

class InterestRateSwap(GenericSwap):
    def annuity(self, discount_curve, pricing_date=None):
        if pricing_date is None:
            pricing_date = self.start_date
        a = 0
        for i in range(1, len(self.fixed_leg_dates)):
            if pricing_date > self.fixed_leg_dates[i]:
                continue
            a += discount_curve.df(self.fixed_leg_dates[i])
        return a

    def swap_rate(self, discount_curve, libor_curve  pricing_date=None):
        if pricing_date is None:
            pricing_date = self.start_date
        s = 0
        for j in range(1, len(self.floating_leg_dates)):
            F = libor_curve.forward_rate(pricing_date, self.floating_leg_dates[j-1])
            tau = (self.floating_leg_dates[j] - \
                self.floating_leg_dates[j-1]).days / 360
            P = discount_curve.df(self.floating_leg_dates[j])
            s += F * tau * P
        return s / self.annuity(discount_curve)

    def npv(self, discount_curve, libor_curve, pricing_date=None):
        if pricing_date is None:
            pricing_date = self.start_date
        S = self.swap_rate(discount_curve, libor_curve, pricing_date)
        A = self.annuity(discount_curve, pricing_date)
        return self.notional * (S - self.fixed_rate) * A
\end{ipython}
\begin{finmarkets}
This is just an example. Actually may be an overkill to use inheritance here, since there is not much of code to share between the classes (the implementation of the NPV calculation is different in each of them). Anyway this is a practical application to show how it works.
\end{finmarkets}

\section{Swaptions}
\label{interest-rate-swaptions}

Swaptions are the equivalent of European options for the interest rate markets. They give the option holder the right but not the obligation to enter into an Interest Rate Swap at a predetermined fixed rate at the exercise date \(d_{ex}\).

Clearly the option holder will only choose to do this if the NPV of the underlying swap at \(d_{ex}\) is positive. Looking at the expression of the IRS NPV in terms of the swap rate \(S\) therefore, we can see that the payoff of the swaption is

\begin{equation}
\mathrm{payoff} = N\cdot \mathrm{max}(0, S(d_{\mathrm{ex}}) - K)\cdot\sum D(d, d_i^{\mathrm{fixed}})
\label{eq:swaption_payoff}
\end{equation}

The primary risk with a swaption occurs after you have exercised your right and proceeded with the swap. Should interest rate movements be different to your expectations, the swap may have the opposite effect to what you were trying to achieve with the transaction. You can however reverse or terminate the swap should this happen (remembering you may be required to pay the bank, or the bank will pay you, the residual value of the swap).

It is also important to note, that if interest rates do not rise above the interest rate nominated in the swaption on the exercise date, you have not obtained any benefit from the premium paid for the purchase of the swaption. The premium is the cost of obtaining protection against a rise in interest rates.

\subsection{Swaption Evaluation}

In order to evaluate this payoff the key issue is to estimate $S(d_{\mathrm{ex}})$. This will be shown with two alternative approaches.

\subsubsection{Evaluation through Black-Scholes Formula}
\label{evaluation-through-black-scholes-formula}

In this case, to evaluate the swaption NPV, we are going to use (but not to derive) a generalization of the Black-Scholes formula

\begin{equation}
\mathrm{payoff} = N\cdot A\cdot [S \Phi(d_+) - K\Phi(d_-)]
\end{equation}
where $\Phi$ represents the cumulative distribution function of the normal distribution and

\begin{equation}
\begin{gathered}d_{\pm} = \frac{\mathrm{log}(\frac{S}{K}) \pm \frac{1}{2}\sigma^{2}T}{\sigma\sqrt{T}}\qquad(\sigma~\textrm{is the volatility of the swap rate})\\
A =\sum_{i=1}^{p}D(d, d_{i}^{\mathrm{fixed}})\qquad\mathrm{(annuity})
\end{gathered}
\end{equation}

As an example let's consider a swaption whose underlying 6M-IRS has a notional of 1~M, fixed rate of 1\%, and a maturity of 4 years. In addition we assume a volatility associated to the swap rate of 7\%.

\begin{ipython}
from math import log
from scipy.stats import norm
from dateutil.relativedelta import relativedelta

def npvSwaptionBS(pricing_date, irs, sigma, discount_curve, libor_curve, T):
    A = irs.annuity(discount_curve, pricing_date)
    S = irs.swap_rate(discount_curve, libor_curve, pricing_date)
    K = irs.fixed_rate
    N = irs.notional
    d_plus = (log(S/K) + 0.5 * sigma**2 * T) / (sigma * T**0.5)
    d_minus = (log(S/K) - 0.5 * sigma**2 * T) / (sigma * T**0.5)
    return irs.notional * A * (S * norm.cdf(d_plus) - K * norm.cdf(d_minus))

sigma = 0.07
pricing_date = date(2019, 11, 15)
exercise_date = start_date
irs = InterestRateSwap(pricing_date, start_date, 1e6, 0.01, 6, 4)
T = (exercise_date - pricing_date).days / 365
npv = npvSwaptionBS(pricing_date, irs, sigma, dc, lc, T)
print("Swaption NPV with BS: {:.3f} EUR".format(npv))
\end{ipython}
\begin{ioutput}
Swaption NPV with BS: 2392.133 EUR
\end{ioutput}

\subsubsection{Evaluation through Monte Carlo Simulation}
\label{evaluation-through-monte-carlo-simulation}

In this second case we start from the current swap rate \(S(d)\) evaluated at the pricing date \(d\) and assume that it follows a log-normal stochastic process with zero drift, i.e. its distribution at \(d_{\mathrm{ex}}\) (exercise date) is 

\(S(d_{\mathrm{ex}}) = S(d)\mathrm{exp}(-\frac{1}{2}\sigma^{2}T+\sigma Z\sqrt{T})\)
\noindent
where $Z\approx\mathcal{N}(0,1)$. This assumption is not correct since we know that interest rate follows different processes, but it is ok for illustrative purposes. 

To perform the simulation Eq.~\ref{eq:swaption_payoff} can be used:

\begin{itemize}
\tightlist
\item sample the normal distribution \(\mathcal{N}(0, 1)\) to calculate a large number of scenarios for \(S(d_{\mathrm{ex}})\);
\item evaluate the underlying swap's NPV at the expiry date, and consequently the swaption's payoff, for each scenario;
\item take the average of these values to get the final estimate.
\end{itemize}

\begin{ipython}
import numpy as np
from math import exp, sqrt
from numpy.random import normal, seed

n_scenarios = 100000
discounted_payoffs = []
seed(1)
T = (exercise_date - pricing_date).days / 365
A = irs.annuity(dc, pricing_date)
S0 = irs.swap_rate(dc, lc, pricing_date)
for i_scenario in range(n_scenarios):
    S = S0 * exp(-0.5 * sigma * sigma * T +
        sigma * sqrt(T) * normal())
    swap_npv = irs.notional * max(0,S - irs.fixed_rate) * A
    discounted_payoffs.append(max(0, swap_npv))

npv_mc = np.mean(discounted_payoffs)
print("Swaption NPV: {:.2f} EUR".format(npv_mc))
\end{ipython}
\begin{ioutput}
Swaption NPV: 2402.20 EUR
\end{ioutput}

%Note that this is not \emph{strictly speaking} the correct way of
%calculating the swaption NPV, the reason being that one should calculate
%the swap NPV at the expiry date of the swaption, apply the payoff
%function max(0, \ldots{}) and \emph{then} discount from the expiry date
%to today.
%
%However, it's simpler to calculate it as above and it doesn't make any
%difference for the result, since
%\[ DF\cdot \mathrm{max}(0, \mathrm{SwapNPVAtExpiry}) = \mathrm{max}(0, DF \cdot\mathrm{SwapNPVAtExpiry}) \]

\begin{finmarkets}
Add to \texttt{finmarkets.py} a new class (e.g. \texttt{Swaption}) capable of valuting interest rate swaptions both with Monte Carlo simulation and Black-Scholes formula.
\end{finmarkets}

\subsection{Confidence Interval of MC Simulation}

Using the confidence interval~\ref{sec:confidence_interval} it can be checked whether the Monte Carlo estimate of the swaption payoff is in agreement with what computed using the Black-Scholes formula.
Let's then calculate the 95\% confidence level for the swaption simulation:

\begin{ipython}
npv_error = 1.96 * np.std(discounted_payoffs)/sqrt(n_scenarios)
print("Swaption NPV: {:.2f} EUR (+/- {:.2f} EUR with 95% confidence)"\
    .format(npv_mc, npv_error))
\end{ipython}
\begin{ioutput}
Swaption NPV: 2402.20 EUR (+/- 17.47 EUR with 95% confidence)
\end{ioutput}

The NPV calculated via the Black-Scholes formula falls well within the confidence interval produced by the Monte Carlo simulation:

\begin{itemize}
\tightlist
\item
  Swaption NPV (BS): \euro{2392.1}
\item
  Swaption NPV (MC): \euro{2402.2} $\pm$ 17.5
\end{itemize}
so we can assert that the two estimates are in agreement at the 95\% confidence level.

\section*{Exercises}
\input{irs_ex_text}

\begin{thebibliography}{9}
\bibitem{bib:black_scholes_swaption} G. West and L. West, \href{http://janroman.dhis.org/finance/Black/IntroToBlack.pdf}{\emph{Introduction to Black's Model for Interest Rate Derivatives}}, Financial Modelling Agency [Online]
\end{thebibliography}