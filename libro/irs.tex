\chapter{Interest Rate Swaps and Swaptions}
\label{interest-rate-swaps-and-swaptions}

In Chapter~\ref{sec:swaps-and-bootstrapping} we introduced a particular type of swap, the Overnight Index Swap, here we describes a more general Interest Rate Swap and see how it can underlying a swaption, the analogous of the European options for interest rate market.

\section{Interest Rate Swaps}\label{interest-rate-swaps}

Interest rate swaps (IRS) consist of two legs: a floating and a fixed. The
contract parameters are:

\begin{itemize}
\tightlist
\item
  start date \(d_0\);
\item
  notional \(N\);
\item
  fixed rate \(K\);
\item
  floating rate tenor (months);
\item
  maturity (years).
\end{itemize}

The floating leg pays the reference LIBOR fixing at a frequency equal to
the tenor of the floating rate, so for example an IRS on a 3-month
LIBOR will pay a floating coupon every three months, an IRS on 6-month
EURIBOR pays the floating coupon every six months and so on.

The fixed leg pays a predetermined cash flow at annual frequency,
regardless of the tenor of the underlying floating rate (for simplicity we will only consider swaps with maturities which are multiples of 1 year).

Before going into the details of the valuation of IRSs, we need to
modify the \texttt{generate\_swap\_dates} function in
\texttt{finmarkets} module to generate the payment dates for both the
fixed and floating legs. 
The modification consists of the addition of a new input
parameter, the tenor, which was previously fixed to 12 months.

\begin{ipython}
from datetime import date
from dateutil.relativedelta import relativedelta

def generate_swap_dates(start_date, n_months, tenor_months=12):
    dates = []
    for n in range(0, n_months, tenor_months):
        dates.append(start_date + relativedelta(months=n))
        dates.append(start_date + relativedelta(months=n_months))
    return dates
    
generate_swap_dates(date.today(), 16, 3)
\end{ipython}
\begin{ioutput}
[datetime.date(2020, 10, 15),
 datetime.date(2021, 1, 15),
 datetime.date(2021, 4, 15),
 datetime.date(2021, 7, 15),
 datetime.date(2021, 10, 15),
 datetime.date(2022, 1, 15),
 datetime.date(2022, 2, 15)]
\end{ioutput}
Having set the default value of \texttt{tenor\_months} to 12 allows the new function to be \emph{backward-compatible}, meaning that old code based on its previous version will keep working, being written on the assumption of a fixed tenor of twelve months. 
       
Using this function and the contract parameters we will be able to determine a sequence of payment dates for each leg of the IRS.

\subsection{IRS Valuation}\label{irs-valuation}

Let \(d_0=d_0^{\mathrm{fixed}},...,d_p^{\mathrm{fixed}}\) be the fixed leg payment dates and
\(d_0=d_0^{\mathrm{float}},...,d_p^{\mathrm{float}}\) be the floating leg payment dates, and let's use the following notation:

\begin{itemize}
\tightlist
\item
  \(d\) the pricing date;
\item
  \(D(d, d')\) the discount factor observed in date \(d\) for the value
  date \(d'\);
\item
  \(F(d, d', d'')\) the forward rate observed in date \(d\) for the
  period \([d', d'']\); 
  \item the tenor is \(\tau = d'' - d'\).
\end{itemize}
The NPV of the fixed leg is calculated as follows:

\begin{equation}
\mathrm{NPV}_{\mathrm{fixed}}(d, K) = N\cdot K\cdot\sum_{i=1}^{n}D(d, d_{i}^{\mathrm{fixed}})\end{equation}
while the NPV of the floating leg is:

\begin{equation}\mathrm{NPV}_{\mathrm{float}}(d) = N\cdot\sum_{i=1}^{m}F(d, d_{j-1}^{\mathrm{float}}, d_{j}^{\mathrm{float}}) \cdot \frac{d_{j}^{\mathrm{float}}-d_{j-1}^{\mathrm{float}}}{360}
\cdot D(d, d_{i}^{\mathrm{float}})\end{equation}

Therefore the NPV of the swap (seen from the point of view of the counter-party which receives the floating leg) is

\begin{equation}\mathrm{NPV}(d, K) = \mathrm{NPV}_{\mathrm{float}}(d) - \mathrm{NPV}_{\mathrm{fixed}}(d, K)\end{equation}

For reasons which will become apparent later, it's actually more convenient to express the NPV of an IRS as a function of the fair value fixed rate \(S\) of the IRS, also known as the \textbf{swap rate}, which is the value of K which makes \(\mathrm{NPV}(d)=0\). On the basis of the previous expressions, we can easily calculate \(S\) as

\begin{equation}
\begin{gathered}
\mathrm{NPV}_{\mathrm{fixed}}(d, S) = \mathrm{NPV}_{\mathrm{float}}(d)\\
N\cdot S\cdot\sum_{i=1}^{n}D(d, d_{i}^{\mathrm{fixed}}) = N\cdot\sum_{i=1}^{m}F(d, d_{j-1}^{\mathrm{float}}, d_{j}^{\mathrm{float}}) \cdot \frac{d_{j}^{\mathrm{float}}-d_{j-1}^{\mathrm{float}}}{360} \cdot D(d, d_{i}^{\mathrm{float}})\\
S=\frac{\sum_{i=1}^{m}F(d, d_{j-1}^{\mathrm{float}}, d_{j}^{\mathrm{float}}) \cdot \frac{d_{j}^{\mathrm{float}}-d_{j-1}^{\mathrm{float}}}{360}
\cdot D(d, d_{i}^{\mathrm{float}})}{\sum_{i=1}^{n}D(d, d_i^{\mathrm{fixed}})}
\end{gathered}
\end{equation}

Once we have calculated \(S\), we can express the \(\mathrm{NPV}\) of an IRS as follows:

\begin{equation}
\begin{split}&\mathrm{NPV}(d, K) = \mathrm{NPV}_{\mathrm{float}}(d) - \mathrm{NPV}_{\mathrm{fixed}}(d, K) = \\ 
&= \underbrace{\mathrm{NPV}_{\mathrm{float}}(d) - \mathrm{NPV}_{\mathrm{fixed}}(d, S)}_{\mathrm{=\;0}} + \mathrm{NPV}_{\mathrm{fixed}}(d, S) - \mathrm{NPV}_{\mathrm{fixed}}(d, K) \\ 
& = N\cdot(S-K)\cdot\underbrace{\sum_{i=1}^{n}D(d, d_{i}^{\mathrm{fixed}})}_{\mathrm{'annuity'}}
\end{split}
\end{equation}

For convenience the relevant inputs that will be used later (LIBOR and discount curve definitions) have been saved in the files  \href{https://drive.google.com/file/d/1dm5oZnZKmJM6UrV0L32OcqD5Tzs9SI9A/view?usp=sharing}{libor\_curve.xlsx} and \href{https://drive.google.com/file/d/14R22r7m-6VpQ_P79D3qHdK0QN_mOQ_UB/view?usp=sharing}{discount\_curve.xlsx} respectively.

\begin{ipython}
import pandas as pd
from datetime import date
from finmarkets import DiscountCurve, ForwardRateCurve

observation_date = date.today()
discount_data = pd.read_excel('discount_curve.xlsx')
libor_data = pd.read_excel('libor.xlsx')
dc = DiscountCurve(pricing_date,
discount_data['pillar'].dt.date.tolist(),
discount_data['discount_factor'].tolist())
fr = ForwardRateCurve(libor_data['date'].dt.date.tolist(),
libor_data['rate'].tolist())

print(dc.df(date(2021, 1, 1)))
print (fr.forward_rate(date(2021, 1, 1)))
\end{ipython}
\begin{ioutput}
1.0041959227522805
0.060712328767123284
\end{ioutput}

Now we can implement the \texttt{InterestRateSwap} class to valuate IRS
contracts.

\begin{ipython}
class InterestRateSwap:
    def __init__(self, start_date, notional,
        fixed_rate, tenor_months, maturity_years):
        self.start_date = start_date
        self.notional = notional
        self.fixed_rate = fixed_rate
        self.fixed_leg_dates = \
            generate_swap_dates(start_date, 12 * maturity_years)
        self.floating_leg_dates = \
            generate_swap_dates(start_date, 12 * maturity_years, tenor_months)
    
    def annuity(self, discount_curve, obs_date=self.start_date):
        a = 0
        for i in range(1, len(self.fixed_leg_dates)):
            if obs_date > self.fixed_leg_dates[i]:
                continue
            a += discount_curve.df(self.fixed_leg_dates[i])
        return a

    def swap_rate(self, discount_curve, libor_curve):
        s = 0
        for j in range(1, len(self.floating_leg_dates)):
            F = libor_curve.forward_rate(self.floating_leg_dates[j-1])
            tau = (self.floating_leg_dates[j] - \
                self.floating_leg_dates[j-1]).days / 360 
            P = discount_curve.df(self.floating_leg_dates[j])
            s += F * tau * P
        return s / self.annuity(discount_curve)

    def npv(self, discount_curve, obs_date=self.start_date, libor_curve):
        S = self.swap_rate(discount_curve, libor_curve)
        A = self.annuity(discount_curve, obs_date)
        return self.notional * (S - self.fixed_rate) * A
\end{ipython}

\begin{finmarkets}
This class goes into \texttt{finmarkets} financial module to manage Interest Rate Swaps.
\end{finmarkets}
Let's test our class instantiating an IRS with 1~M notional, fixed rate
of 5\%, 6 month tenor and a maturity of 4 years; discount and LIBOR
curves are the same as before.

\begin{ipython}
start_date = date.today() + relativedelta(months=1)
irs = InterestRateSwap(start_date, 1e6, 0.05, 6, 4)
print ("{:.2f} EUR".format(irs.npv(dc, fr)))
\end{ipython}
\begin{ioutput}
22453.12 EUR
\end{ioutput}

\textbf{Can you guess what could be the \textbf{swap rate} given that the NPV obtained above ?}
Since we are looking at this contracts from the point of view
of the receiver of the floating leg and that the swap rate is the rate that makes the total NPV equal to 0, the NPV of the fixed leg has to be increased to balance the value of the floating leg so the swap rate will be higher than the fixed rate of the IRS.

\begin{ipython}
print ("{}".format(irs.swap_rate(dc, fr)))
\end{ipython}
\begin{ioutput}
0.054458656972619764
\end{ioutput}
    
To check if we have computed correctly the swap rate we can
instantiate a new IRS with fixed rate equal to the just calculated swap
rate and print its NPV, it should come very close to 0.

\begin{ipython}
irs2 = InterestRateSwap(start_date, 1e6, 0.054458656972619764, 6, 4)
print ("{:.2f} EUR".format(irs2.npv(dc, fr)))
\end{ipython}
\begin{ioutput}
0.0 EUR
\end{ioutput}
    
\section{Inheritance Again}
Now that we have introduced two kinds of swap we can try to make an alternative implementation of their classes, this time using inheritance.

The base (or parent) class will be \texttt{GenericSwap} and it will implement just the constructor taking in input the basic data characterizing a swap: notional, maturity, tenor and rate of the fixed leg. We will slightly modify the implementation of the \texttt{OvernightIndexSwap} class since now the payment dates are computed directly in the constructor of \texttt{GenericSwap}.

\begin{ipython}
class GenericSwap:
    def __init__(self, start_date, notional,
        fixed_rate, maturity_years, tenor_months=12):
        self.notional = notional
        self.fixed_rate = fixed_rate
        self.fixed_leg_dates = \
            generate_swap_dates(start_date, 12 * maturity_years)
        self.floating_leg_dates = \
            generate_swap_dates(start_date, 12 * maturity_years, tenor_months)
        self.maturity = maturity_years

    def npv(self):
        print ("{} doesn't implement npv method.".format(self.__name__))

class OvernightIndexSwap(GenericSwap):
    def npv_floating_leg(self, discount_curve):
        return self.notional * (discount_curve.df(self.floating_leg_dates[0]) -
            discount_curve.df(self.floating_leg_dates[-1]))

    def npv_fixed_leg(self, discount_curve):
        npv = 0
        for i in range(1, len(self.fixed_leg_dates)):
            start_date = self.fixed_leg_dates[i-1]
            end_date = self.fixed_leg_dates[i]
            tau = (end_date - start_date).days / 360
            df = discount_curve.df(end_date)
            npv += df * tau 
        return self.notional * self.fixed_rate * npv

    def npv(self, discount_curve):
        float_npv = self.npv_floating_leg(discount_curve)
        fixed_npv = self.npv_fixed_leg(discount_curve)
        return float_npv - fixed_npv

class InterestRateSwap(GenericSwap):
    def annuity(self, discount_curve, obs_date=self.start_date):
        a = 0
        for i in range(1, len(self.fixed_leg_dates)):
            if obs_date > self.fixed_leg_dates[i]:
                continue
            a += discount_curve.df(self.fixed_leg_dates[i])
        return a

    def swap_rate(self, discount_curve, libor_curve):
        s = 0
        for j in range(1, len(self.floating_leg_dates)):
            F = libor_curve.forward_rate(self.floating_leg_dates[j-1])
            tau = (self.floating_leg_dates[j] - \
                self.floating_leg_dates[j-1]).days / 360
            P = discount_curve.df(self.floating_leg_dates[j])
            s += F * tau * P
        return s / self.annuity(discount_curve)

    def npv(self, discount_curve, libor_curve, obs_date=self.start_date):
        S = self.swap_rate(discount_curve, libor_curve)
        A = self.annuity(discount_curve, obs_date)
        return self.notional * (S - self.fixed_rate) * A
\end{ipython}
\begin{finmarkets}
This is just an example. Actually may be an overkill to use inheritance here, since there is not much of code to share between the classes (the implementation of the NPV calculation is different in each of them).
Anyway this is a practical application to show how it works.
\end{finmarkets}

\section{Swaptions}\label{interest-rate-swaptions}

Swaptions are the equivalent of European options for the interest rate markets. They give the option holder the right but not the obligation to enter into an Interest Rate Swap at a predetermined fixed rate at the exercise date \(d_{ex}\).

Clearly the option holder will only choose to do this if the NPV of the underlying swap at \(d_{ex}\) is positive. Looking at the expression of the IRS NPV in terms of the swap rate \(S\) therefore, we can see that the payoff of the swaption is

\begin{equation}
\mathrm{payoff} = N\cdot \mathrm{max}(0, S(d_{\mathrm{ex}}) - K)\cdot\sum D(d, d_i^{\mathrm{fixed}})
\label{eq:swaption_payoff}
\end{equation}

In order to evaluate this payoff the key issue is to estimate $S(d_{\mathrm{ex}})$. This will be shown with two alternative approaches.

\subsection{Evaluation through Black-Scholes Formula}
\label{evaluation-through-black-scholes-formula}

In this case, to evaluate the swaption NPV, we are going to use (but not to derive) a generalization of the Black-Scholes formula

\begin{equation}
\mathrm{payoff} = N\cdot A\cdot [S \Phi(d_+) - K\Phi(d_-)]
\end{equation}
where $\Phi$ represents the cumulative distribution function of the normal distribution and

\begin{equation}
\begin{gathered}d_{\pm} = \frac{\mathrm{log}(\frac{S}{K}) \pm \frac{1}{2}\sigma^{2}T}{\sigma\sqrt{T}}\qquad(\sigma~\textrm{is the volatility of the swap rate})\\
A =\sum_{i=1}^{p}D(d, d_{i}^{\mathrm{fixed}})\qquad\mathrm{(annuity})
\end{gathered}
\end{equation}

As an example let's consider a swaption whose underlying 6M-IRS has a notional of 1~M, fixed rate of 1\%, and a maturity of 4 years. In addition we assume a volatility associated to the swap rate of 7\%.

\begin{ipython}
from math import log
from scipy.stats import norm
from dateutil.relativedelta import relativedelta

def npvSwaptionBS(irs, sigma,
    discount_curve, libor_curve, T):
    A = irs.annuity(discount_curve)
    S = irs.swap_rate(discount_curve, libor_curve)
    K = irs.fixed_rate
    N = irs.notional
    d_plus = (log(S/K) + 0.5 * sigma**2 * T) / (sigma * T**0.5)
    d_minus = (log(S/K) - 0.5 * sigma**2 * T) / (sigma * T**0.5)
    return irs.notional * A * (S * norm.cdf(d_plus) - K * norm.cdf(d_minus))

sigma = 0.07
irs = InterestRateSwap(start_date, 1e6, 0.01, 6, 4)
exercise_date = start_date
T = (exercise_date - observation_date).days / 365
npv = npvSwaptionBS(irs, sigma, dc, fr, T)
print("Swaption NPV with BS: {:.3f} EUR".format(npv))
\end{ipython}
\begin{ioutput}
Swaption NPV with BS: 223887.09 EUR
\end{ioutput}

\subsection{Evaluation through Monte Carlo Simulation}
\label{evaluation-through-monte-carlo-simulation}

In this second case we start from the current swap rate \(S(d)\)
evaluated at the pricing date \(d\), and assume that it follows a
log-normal stochastic process with zero drift, i.e. its distribution at
\(d_{\mathrm{ex}}\) (exercise date) is
\(S(d_{\mathrm{ex}}) = S(d)\mathrm{exp}(-\frac{1}{2}\sigma^{2}T+\sigma Z\sqrt{T})\)
where $Z\approx\mathcal{N}(0,1)$.
This assumption is not correct since we know that interest rate follows 
different processes, but it is ok for illustrative purposes. 

To perform the simulation we can explot Eq.~\ref{eq:swaption_payoff}:

\begin{itemize}
\tightlist
\item
  sample the normal distribution \(\mathcal{N}(0, 1)\) to calculate a
  large number of scenarios for \(S(d_{\mathrm{ex}})\);
\item
  evaluate the underlying swap's NPV at the expiry date, and
  consequently the swaption's payoff, for each scenario;
\item
  take the average of these values to get the final estimate.
\end{itemize}

\begin{ipython}
import numpy as np
from math import exp, sqrt
from numpy.random import normal, seed

n_scenarios = 100000
discounted_payoffs = []
seed(1)
T = (exercise_date - observation_date).days / 365
A = irs.annuity(dc)
S0 = irs.swap_rate(dc, fr)
for i_scenario in range(n_scenarios):
    S = S0 * exp(-0.5 * sigma * sigma * T +
        sigma * sqrt(T) * normal())
    swap_npv = irs.notional * max(0,S - irs.fixed_rate) * A
    discounted_payoffs.append(max(0, swap_npv))

npv_mc = np.mean(discounted_payoffs)
print("Swaption NPV: {:.2f} EUR".format(npv_mc))
\end{ipython}
\begin{ioutput}
Swaption NPV: 223915.50 EUR
\end{ioutput}

%Note that this is not \emph{strictly speaking} the correct way of
%calculating the swaption NPV, the reason being that one should calculate
%the swap NPV at the expiry date of the swaption, apply the payoff
%function max(0, \ldots{}) and \emph{then} discount from the expiry date
%to today.
%
%However, it's simpler to calculate it as above and it doesn't make any
%difference for the result, since
%\[ DF\cdot \mathrm{max}(0, \mathrm{SwapNPVAtExpiry}) = \mathrm{max}(0, DF \cdot\mathrm{SwapNPVAtExpiry}) \]

\begin{finmarkets}
Add to \texttt{finmarkets.py} a new class (e.g. \texttt{Swaption}) capable of valuting interest rate swaptions both with Monte Carlo simulation and Black-Scholes formula.
\end{finmarkets}
\subsection{Confidence Interval of MC Simulation}

Using the confidence interval~\ref{sec:confidence_interval} we can check whether the Monte Carlo estimate of the swaption payoff is in agreement with what computed using the Black-Scholes formula.
Let's then calculate the 95\% confidence level for the swaption simulation:

\begin{ipython}
npv_error = 1.96 * np.std(discounted_payoffs)/sqrt(n_scenarios)
print("Swaption NPV: {:.2f} EUR (+/- {:.2f} EUR with 95% confidence)"\
    .format(npv_mc, npv_error))
\end{ipython}
\begin{ioutput}
Swaption NPV: 223915.50 EUR (+/- 34.62 EUR with 95\% confidence)
\end{ioutput}

The NPV calculated via the Black-Scholes formula falls well within the confidence interval produced by the Monte Carlo simulation:

\begin{itemize}
\tightlist
\item
  Swaption NPV (BS): \euro{223887}
\item
  Swaption NPV (MC): \euro{223915} $\pm$ 34
\end{itemize}
so we can assert that the two estimates are in agreement at the 95\% confidence level.

\section{Exercises}
\input{irs_ex_text}

\begin{thebibliography}{9}
\bibitem{bib:black_scholes_swaption} G. West and L. West, \href{http://janroman.dhis.org/finance/Black/IntroToBlack.pdf}{\emph{Introduction to Black's Model for Interest Rate Derivatives}}, Financial Modelling Agency [Online]
\end{thebibliography}