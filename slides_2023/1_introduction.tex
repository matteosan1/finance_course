\documentclass{beamer}
\usetheme{afm}

\title{Introduction}
\author{Matteo Sani - \href{mailto:matteo.sani@unisi.it}{matteo.sani@unisi.it}}

\begin{document}
\begin{frame}[plain]
  \maketitle
\end{frame}

\begin{frame}{This is me}
	\begin{itemize}
		\begin{columns}
			\column{0.45\linewidth}
	\item I am \textbf{Matteo Sani} former PhD Researcher in Particle Physics at University California San Diego and CERN.
	\item In {\color{red}2017} I joined the Quantitative Group at \textbf{MPS Capital Services} (now just \textbf{MPS}).
	\column{0.55\linewidth}
	\includegraphics[width=1.\linewidth]{CMScollaboration}
	\end{columns}
	\end{itemize}
\begin{block}{}
	\begin{center}
Since {\color{red}2019} I am in charge of the "coding" part of the \textbf{Financial Market Course}.
\end{center}
\end{block}
\end{frame}

\begin{frame}{The Course}
  \begin{itemize}
  \item Official WebSite: \href{https://sites.google.com/view/finmark2023}{FinMark2023}
  \item Facebook Group: \href{https://www.facebook.com/groups/1484320032353854}{UniSi Financial Markets 2023/24}
  \item \textbf{The course consists of 10 lessons (Wednesday 18.00 - 19.30) in "Aula Informatica 2".}
  \begin{center}
  	\begin{tabular}{|c|c|}
  		\hline
  		UserName & Password \\
  		\hline
  		market & freschi01 \\
  		\hline
  	\end{tabular}
  \end{center}
	\vspace{0.5cm}
\end{itemize}
\begin{block}{Goal of the Course}
  Provide you with the basic numerical tools developed with \texttt{python} to solve real world financial problems.
  \end{block}
  
\end{frame}

\begin{frame}{Topics}
  \begin{columns}
    \column{0.4\linewidth}
    \begin{tabular}{|c|}
    	\hline
    	\textbf{Mathematical Techniques}\\
    	\hline\hline
    	interpolation \\
    	\hline
    	bootstrapping\\
    	\hline
    	Monte Carlo simulation\\
    	\hline
    	copulas\\
    	\hline
    	numerical optimization\\
    	\hline
    \end{tabular}
%    \begin{block}{Mathematical Techniques}
%      \begin{itemize}
%      \item interpolation;
%      \item bootstrapping;
%      \item Monte Carlo simulation;
%      \item copulas;
%      \item numerical optimization.
%      \end{itemize}
%    \end{block}
    \column{0.4\linewidth}
        \begin{tabular}{|c|}
    	\hline
    	\textbf{Financial Subjects}\\
    	\hline\hline
    	bonds\\
    	\hline
    	pricing of IR and Credit derivatives\\
    	\hline
    	Value at Risk, credit risk\\
    	\hline
    	Credit Value Adjustment\\
    	\hline
    	asset allocation\\
    	\hline
    \end{tabular}
%    \begin{block}{Financial Topics}
%      \begin{itemize}
%      \item bonds;
%      \item pricing of IR and Credit derivatives;
%      \item Value at Risk, credit risk;
%      \item Credit Value Adjustment;
%      \item portfolio optimization.
%      \end{itemize}
%    \end{block}
  \end{columns}
\vspace{0.5cm}
\begin{center}
    \begin{tabular}{|c|}
	\hline
	\textbf{Machine Learning}\\
	\hline\hline
	basic of deep learning theory\\
	\hline
	ML financial applications (MLP Networks, Convolutional Networks)\\
	\hline
\end{tabular}
\end{center}
%  \begin{block}{Machine Learning (ML)}
%    \begin{itemize}
%    \item basic deep learning theory;
%    \item ML financial application (Neural Networks, Convolutional Networks..).
%    \end{itemize}
%  \end{block}
\end{frame}

\begin{frame}{Text Books}
  \begin{itemize}
    \item \href{https://drive.google.com/file/d/1GnlyuB4KkUbzqL7tf6nju-ZEqnfQrRa4/view?usp=drive_link}{Lecture notes} are available on the website with formulas full derivations and additional material.
    \item \href{https://drive.google.com/file/d/1wrOj1xTehJvd4UCDCVl7WnUFST16IZJP/view?usp=drive_link}{Exercises (with solutions)} for each chapter are also available. 
    \item You are encouraged to do the exercises and send me by email your homework in case of doubts or questions (I will correct and give you feedback on what you have done !).
    \item \textbf{In general do not hesitate to contact me, I am always available and usually quite responsive at \href{mailto:matteo.sani@unisi.it}{matteo.sani@unisi.it}.}
  \end{itemize}
\end{frame}

\begin{frame}{Why \texttt{python} ?}
  \begin{itemize}
  \item \texttt{python} is widely used \textbf{even if it is slower than other languages} because:
    \begin{itemize}
    \item it is a productive, very concise and expressive language and requires little time, effort, and lines of code to perform the same operations than with other languages;
    \item it has a rich set of libraries and frameworks;
    \item it is maintained by a large community of users.
    \end{itemize}

    \item \textbf{But unfortunately not all that glitters is gold !}

    \item \texttt{python} is an interpreted language: it takes a sequence of instructions, reads and executes it.
  \end{itemize}
  
  \begin{columns}
    \column{0.35\linewidth}
    This is different from other programming languages like \texttt{C} or \texttt{C++} where the code is \emph{compiled} into a language that computers can understand directly (\emph{machine language}).
    \column{0.65\linewidth}
    \begin{figure}[h]
      \begin{center}
        \includegraphics[width=0.8\linewidth]{compiled_vs_interpreted}
      \end{center}
    \end{figure}
  \end{columns}
\end{frame}

\begin{frame}{Compiled vs Interpreted}
  \begin{itemize}
  \item As a result, \texttt{python} is essentially an interactive programming language.
  \item You can program and see the results almost at the same time. 
  \item \emph{Very nice} when developing a new project since \emph{compilation time} can be quite long (just to give an idea the compilation of our \texttt{C++} financial code takes about one hour). 
  \item However there are \textbf{drawbacks} in term of performance, the translation to machine language has to be done in real-time resulting in slower execution times.
  \end{itemize}
\end{frame}

\begin{frame}{\texttt{Python} Language Recap}
  \begin{itemize}
    \item Most of you should be already accustomed to \texttt{python}.
    \item Anyway the first few Chapters of the \href{https://drive.google.com/file/d/1GnlyuB4KkUbzqL7tf6nju-ZEqnfQrRa4/view?usp=drive_link}{lecture notes} cover in some detail its main features.
    \item Otherwise you can take a look at one of the thousands \texttt{python} tutorials available on the web.
    \item Today we are just going to look at some more advanced or financial related aspects here.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Modules}
  \begin{itemize}
  \item Frequently used functions can be written in a \emph{module} and \emph{imported} when needed, instead of copying their definitions into different programs many times.
  \item In essence modules refer to a file containing \texttt{python} code and are used to break down large programs into small manageable and organized files. 
  \item There are thousands of modules available for \texttt{python} and you can also write your own and distribute it to the community.
  \item \textbf{The modules we are going to use most are: \texttt{pandas}, \texttt{datetime}, \texttt{matplotlib}, \texttt{scipy}, \texttt{numpy}, \texttt{math}}
  \item  Lecture notes contain a dedicated Chapter to the first three of them.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Modules}
\begin{ipython}
import math
help(math)
\end{ipython}
\begin{ioutput}
Help on built-in module math:

NAME
    math

DESCRIPTION
    This module provides access to the mathematical functions
    defined by the C standard.

FUNCTIONS
    acos(x, /)
        Return the arc cosine (measured in radians) of x.
\end{ioutput}
\begin{ipython}
dir(math)
\end{ipython}
\begin{ioutput}
['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos',
 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', ...
\end{ioutput}    
\end{frame}

\begin{frame}[fragile]{Using a Module}
  There are several ways to call a module:
  \begin{ipython}
import math
import matplotlib.pyplot as plt

# functions inside the module can be accessed as alias.function
math.log(10)
plt.show()

# to avoid prepending the module name in each call
from math import *

log(10)

# only specific functions can be imported
from math import exp, asin

exp(-4)
asin(0.333)
log(10) # GIVES AN ERROR !
\end{ipython}
\end{frame}

\begin{frame}[fragile]{\texttt{finmarkets} Module}
  \begin{itemize}
  \item Throughout this course we will review the code of a financial module: \texttt{finmarkets}.
  \item We will study and analyze the implementation of most of its functionalities.
  \item Although we are going to write from scratch several parts of the module a fully working version is available in the testing module repository \texttt{pypi}.
  \item In order to make it available for your installation just download it with:
\begin{ipython}
pip install --index-url https://test.pypi.org/simple finmarkets
\end{ipython}
  \item Similarly, to use it within \textbf{Google Colab}, execute a cell with the previous command adding a \texttt{!} in front.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\texttt{datetime}}
  \begin{itemize}
  \item We will frequently use \texttt{datetime} module, which is dedicated to date and time.
  \item In addition we rely on \texttt{dateutil.relativedelta} to perform operations on dates (dedicated Sections in the notes).
  \end{itemize}
  \begin{ipython}
from datetime import date
from dateutil.relativedelta import relativedelta
		
d = date.today()
d1 = date(2023, 12, 25)
print (d, d1, (d1 - d).days)
print (d1.strftime('%d/%m/%Y'), d1.weekday())
print (d + relativedelta(days=45))
print (d + relativedelta(months=45))
\end{ipython}
\begin{ioutput}
2022-09-27 2023-12-25 454
25/12/2023 0
2022-11-11
2026-06-27
\end{ioutput}
\end{frame}

\begin{frame}{Payment Dates Generator}
  \begin{itemize}
  \item Since we will often need to create lists of dates (e.g. a contract payment dates), let's develop an utility that does that for us.
  \item This is the first example of the utilities implemented in the \texttt{finmarkets} module.
  \item The function we are going to code takes as input:
    \begin{itemize}
    \item \emph{starting date}: the first date of the list;
    \item \emph{maturity}: a string like \texttt{5y} or \texttt{17m} which represents the length of the list (another utility function in \texttt{finmarkets} takes care of converting the string "5y" into the actual number of days);
    \item \emph{tenor}: a string, with \emph{default value} of \texttt{12m},which defines the frequency of the dates in the list. If the maturity it is not a multiple of the tenor the last period of the sequence will be "truncated" to the last date.
    \end{itemize}
  \item The function returns a list of dates.
  \end{itemize}		
\end{frame}

\begin{frame}[fragile]{Payment Dates Generator}
  \begin{ipython}
from datetime import date
from dateutil.relativedelta import relativedelta
from finmarkets import maturity_from_str
			
def generate_dates(start_date, maturity, tenor="1y"):
    maturity_months = int(round(maturity_from_str(maturity), 0))
    tenor_months = int(round(maturity_from_str(tenor), 0))
    dates = []
    for d in range(0, maturity_months, tenor_months):
        dates.append(start_date + relativedelta(months=d))
    dates.append(start_date + relativedelta(months=maturity_months))
    return dates
			
print (generate_dates(date(2023, 8, 28), "25m"))
\end{ipython}
\begin{ioutput}
[datetime.date(2023, 8, 28), datetime.date(2024, 8, 28),
 datetime.date(2025, 8, 28), datetime.date(2025, 9, 28)]
\end{ioutput}
\end{frame}

\begin{frame}{Discount Factor}
  \begin{itemize}
  \item A \emph{discount factor} is the number that multiplies a future cash-flow value to discount it back to its \emph{present value}.
    %\item The factor increases over time (meaning the value gets smaller) as the effect of compounding the discount rate builds over time.
  \item It is related to the \emph{time value of money} i.e. there is a difference between the "future value" of a payment and the "present value" of the same payment.
  \item Consider a payment $F$ that is to be made $t$ years in the future, we calculate the present value as
    \begin{equation}
      PV = \frac{F}{(1+r)^t};\quad PV=F\exp^{-rt}\textrm{ (continouous compounding)}
    \end{equation}
  \item The discount rate $r$ which is used in financial calculations is usually chosen to be equal to the cost of capital, i.e. risk-free rate.
  \end{itemize}
\end{frame}

\begin{frame}{Discount Curve}
  \begin{itemize}
  \item \emph{Discount factors} are usually presented as curves (\emph{discount curves}) where each point represents the discount factor relative to a future date.
  \item Discount curves are analogous to \emph{yield curves} given the relationship between the discount and the rate.
    \begin{figure}[h]
      \begin{center}
        \includegraphics[width=0.55\linewidth]{discount_curve}
      \end{center}
    \end{figure}
  \end{itemize}
\end{frame}

\begin{frame}{Linear Interpolation}
  \begin{itemize}
  \item<1-> Since discount factors are available only at discrete times we need a procedure to determine the factors at \emph{every} time; the simplest technique is called \emph{interpolation}.
  \item<1-> \emph{Interpolation is a method to "determine" new points within a range of a discrete set of known data points.}
  \item<2-> Assume you are traveling by car at \emph{constant speed} (i.e. the traveled distance is $s = v \cdot t$);
  \end{itemize}
   \uncover<3->{
    \begin{figure}[h]
      \begin{center}
        \includegraphics[width=0.4\linewidth]{interp1}
      \end{center}
    \end{figure}}
\end{frame}

\begin{frame}[fragile]{Linear Interpolation}
  \begin{itemize}
  \item<1-> To find $s(\hat{t})$ at $t_1 \leq \hat{t} \leq t_2$ which is not in our sample we can \emph{linearly interpolate} between the two nearest sampled points $s_1$ and $s_2$ (taken at $t_1$ and $t_2$):
    \begin{itemize}
    \item it works pretty much like a \emph{weighted average} of the two sampled distances (full derivation in the notes);
    \item the closer point has more "influence" than the farther in the result.
    \end{itemize}
  \end{itemize}
  \begin{columns}
    \column{0.5\linewidth}
\begin{ipython}
from scipy.interpolate import interp1d

t = [15, 100, 150]
s = [25.75, 171.7, 257.7]

interpolator = interp1d(t, s)
s_tilde = interpolator(60)
print (f"{s_tilde}")
print (f"{s_tilde:.1f}")
# print (f"{interpolator(60):.1f}")
\end{ipython}
\begin{ioutput}
103.01764705882351
103.0
\end{ioutput}
\column{0.5\linewidth}
\only<3->{   
	 \begin{figure}[h]	
        \begin{center}
        \includegraphics[width=0.85\linewidth]{interp2}
        \end{center}
    \end{figure}
}
  \end{columns}
\end{frame}

\begin{frame}{Linear Interpolation}
  \begin{block}{Extrapolation}
    If we believe the relation between our variables stays the same (e.g. keep the same constant velocity in our trip), we can also \emph{extrapolate} values \textbf{outside} our initial sample.
    Nevertheless it is quite dangerous to assume a particular trend for our data, so extrapolation should be avoided as much as possible.

    \texttt{interp1d} function by default doesn't allow to extrapolate a result as you can see, for example, by repeating the previous interpolation replacing 60 with 170.
  \end{block}

  \begin{block}{Always Interpret Critically your Results}
    In this case $t=60$ is almost in the middle of the interval $[t_1, t_2]$, so we expect to get a distance somehow in between $s_1$ and $s_2$, $s(t=60) \approx 100\;\textrm{km}$.
  \end{block}
  \end{frame}

\begin{frame}{Log-linear Interpolation}
  \begin{itemize}
    \item When the function that we want to interpolate is an exponential we can fall back to the previous case by a simple variable transformation. 
      \begin{equation}
        \begin{gathered}
          d = \mathrm{exp}(-r\cdot t) \\
          s = \mathrm{log}(d) = \mathrm{log}(\mathrm{exp}(-r\cdot t)) = -r \cdot t
        \end{gathered}
      \end{equation}

    \item So it is enough to use \texttt{interp1d} with the lists of $t$ and $\log(d)$ and to \emph{exponentiate back at the end} to get the actual value of $d$.
  \end{itemize}
\end{frame}

%\begin{frame}{Limitations of Linear Interpolation}
%  \begin{itemize}
%    \item Interpolation is just an \emph{approximation} and works well when either the function $s$ is linear or we are trying to interpolate between two points that are close enough that $s$ is \emph{almost} linear in that interval;
%    \item intuitively the "curvier" the function the worse the approximation made with simple linear interpolation.
%    \begin{figure}[h]
%      \begin{center}
%        \includegraphics[width=0.55\linewidth]{interp3}
%      \end{center}
%    \end{figure}
%  \end{itemize}
%\end{frame}

\begin{frame}[fragile]{Discount Curve Implementation}
Let's implement a function that given a discount curve return the discount factor at any date.
\begin{ipython}
from datetime import date
from finmarkets import generate_dates
from scipy.interpolate import interp1d
from numpy import log, exp

def df(d, pillars, dfs):
    log_dfs = [log(x) for x in dfs]
    interp = interp1d(pillars, log_dfs)
    return exp(interp(d))
    
pillars = generate_dates(date(2023, 8, 23), '5y')
dfs = [1, 0.98, 0.97, 0.96, 0.95, 0.94]
print (df(date(2024, 3, 15), pillars, dfs))
\end{ipython}
\uncover<2->{{\color{red}This code won't work !} Indeed \texttt{interp1d} needs two lists of \emph{numbers} as $x$ and $y$ but we are passing dates which cannot be interpolated.}
\end{frame}

\begin{frame}[fragile]{Second Implementation}
To avoid issues with the dates we need to convert somehow to numbers: the function \texttt{toordinal()} converts indeed a date to the number of days since 0-01-01 (January $1^{st}$, 0).
\begin{ipython}
def df_v2(d, pillars, dfs):
    d = d.toordinal()
    pillars = [d.toordinal() for d in pillars]
    log_dfs = [log(x) for x in dfs]
    interp = interp1d(pillars, log_dfs)
    return exp(interp(d))
    
pillars = generate_dates(date(2023, 8, 23), '5y')
dfs = [1, 0.98, 0.97, 0.96, 0.95, 0.94]
print (df_v2(date(2024, 3, 15), pillars, dfs))
\end{ipython}
\begin{ioutput}
0.9887480579548313
\end{ioutput}
\end{frame}

\begin{frame}{Object Oriented Programming (OOP)}
  \begin{itemize}
  \item Unfortunately having such kind of functions working on "complex" objects like a discount curve is not ideal.
  \item When the number of curves increases it is hard (and error prone) to keep track separately of each list of pillars and factors. It would be better to have a single structure holding the data and the functions acting on that data. 
  \item \emph{Object Oriented Programming is what we need}.
  \item OOP is a programming model where programs are organized around \textbf{objects}, rather than functions and logic.
  \item Every \emph{object} can be thought of as a dataset with unique attributes and a "behavior".
  \item Examples:
    \begin{itemize}
    \item a human being that is described by properties like name and birthday;
    \item the \emph{abstract concepts} of a discount curve with dates and discount factors.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Classes}
  \begin{itemize}
  \item \emph{Classes} are the key ingredient of Object Oriented Programming.
  \item They are implemented in many modern programming language like \texttt{python}, \texttt{Java}, \texttt{C++}\ldots
  \item In the OOP framework, classes are meant for
    \begin{itemize}
    \item creating objects (a particular data structure);
    \item providing initial values for its state (\emph{member variables or attributes});
    \item implementing their behavior (\emph{member functions or methods}).
    \end{itemize}
  \item \textbf{A class allows to bundle data and methods that work on that data within one single object.}
  \item At the very end \emph{classes} are collections of functions that operate on a dataset. 
  \item \emph{Instances} of that class represent individual datasets (or if you prefer a \emph{specialization} of that class).
  \end{itemize}
\end{frame}

\begin{frame}{Discount Curve Class}
  \begin{itemize}
  \item Let's implement a discount curve class. The \textbf{attributes} of a discount curve (its unique characteristics) are
      \begin{itemize}
      \item list of pillar dates (corresponding to the given discount factors), $t_0,...,t_{n}$;
      \item list of discount factors, $D(t_0),...,D(t_{n})$.
      \end{itemize}
  \item The "behavior" of the discount curve is simply: "provide a discount factor given a generic date (if necessary it must interpolate between existing factors using a log-linear interpolation)".
  \end{itemize}
\end{frame}
      
\begin{frame}[fragile]{Discount Curve Class}
\begin{itemize}
  \item Import the necessary modules
  
  \item Then the \texttt{class} keyword followed by a name is used to start the actual definition.
\begin{ipython}
from numpy import log
from datetime import date
from scipy.interpolate import interp1d  

class DiscountCurve:
\end{ipython}
  \item Define the \emph{constructor} method:
    \begin{itemize}
    \item it is always named as \texttt{\_\_init\_\_};
    \item \textbf{as every other method in a class, takes \texttt{self} as the first argument};
    \item then any number of parameters as desired by the programmer.
    \end{itemize}
  \item \texttt{\_\_init\_\_} allows to specify the initial state of a class by setting its attribute values, in our case pillars and discount factors.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Class Definition}
\begin{ipython}
from numpy import log
from datetime import date
from scipy.interpolate import interp1d  
	
class DiscountCurve:
    def __init__(self, obs_date, pillars, dfs):
        if obs_date not in pillars:
            pillars = [obs_date] + pillars
            dfs = [1] + dfs
        self.pillars = [d.toordinal() for d in pillars]
        self.log_dfs = [log(x) for x in dfs]
        self.interpolator = interp1d(self.pillars, self.log_dfs)
\end{ipython}
\begin{itemize}
\item Variables whose name starts with \texttt{self.} have \emph{class scope}, i.e. are available within each class method.
\item Class attributes have to be defined as \texttt{self.variableName = param}
\item The \texttt{self.} prefix is used to create and access every attribute or method from within the class itself.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Class Instantiation}
  \begin{itemize}
  \item Now that we have the class definition that represents a \emph{generic} discount curve we can specialized it to some \emph{real} curve.
  \item When \emph{instantiating} a class, \texttt{python} first calls the \texttt{\_\_init\_\_} method and initializes the attributes with the parameter we are passing.
  \item \textbf{To access class attributes and methods the dot (.) operator has to be used.}
  \end{itemize}
\begin{ipython}
from finmarkets import generate_dates
			
pillars = generate_dates(date.today(), "5y")
dfs = [1, 0.98, 0.97, 0.96, 0.95, 0.94]      
dc = DiscountCurve(date.today(), pillars, dfs)
print (dc.pillars) # numerical pillars
print (dc.log_dfs) # log dfs
\end{ipython}
\begin{ioutput}
[738755 738761 739127 739492 739857 740222 740588]
[ 0.          0.         -0.02020271 -0.03045921 -0.04082199 -0.05129329
 -0.0618754 ]
\end{ioutput}
\end{frame}

\begin{frame}[fragile]{Discount Factor Method}
\begin{ipython}
from numpy import log, exp
from datetime import date
from scipy.interpolate import interp1d  
	
class DiscountCurve:
    def __init__(self, obs_date, pillars, dfs):
        if obs_date not in pillars:
            pillars = [obs_date] + pillars
            dfs = [1] + dfs
        self.pillars = [d.toordinal() for d in pillars]
        self.log_dfs = [log(x) for x in dfs]
        self.interpolator = interp1d(self.pillars, self.log_dfs)
        
    def df(self, d):
        dto = d.toordinal()   
        if dto < self.pillars[0] or dto > self.pillars[-1]:
            print (f"Cannot extrapolate discount factors (date: {d}).")
            return None
        return exp(self.interpolator(dto))
\end{ipython}
\end{frame}

\begin{frame}[fragile]{Testing the Class}
Compute and plot the discount factor for a date at 6 months from today given this \href{https://github.com/matteosan1/finance_course/raw/develop/input_files/discount_factors_2022-10-05.xlsx}{discount curve}.
\begin{ipython}
import pandas as pd

df = pd.read_excel("discount_factors_2022-10-05.xlsx")
print (df.head())
\end{ipython}
\begin{ioutput}
   months       dfs
0       1  0.999296
1       2  0.998165
2       3  0.996618
3       4  0.995064
4       5  0.993323
\end{ioutput}
\end{frame}

\begin{frame}[fragile]{Testing the Class}
\begin{ipython}
from datetime import date
from dateutil.relativedelta import relativedelta

today = date.today()
pillars = [today + relativedelta(months=i) for i in df['months']]
dc = DiscountCurve(today, pillars, df['dfs'])
df_date = today + relativedelta(days=195)
df0 = dc.df(df_date)
print (f"discount factor at {df_date}: {df0:.4f}")
\end{ipython}
\begin{ioutput}
discount factor at 2024-03-11: 0.9903
\end{ioutput}
\end{frame}

%\begin{frame}[fragile]{Checking the Result}
%\begin{columns}
%\column{0.5\linewidth}
%\begin{ipython}
%import matplotlib.pyplot as plt
%
%plt.plot(pillars[:10], dfs[:10], 
%         marker='o', markersize=10, 
%         label="discount factors")
%plt.scatter(df_date, df0, marker='X', 
%            s=100, color='red', 
%            label='interp. df')
%plt.xticks(rotation=45)
%plt.grid(True)
%plt.legend()
%plt.show()
%\end{ipython}
%\column{0.5\linewidth}
%    \begin{figure}[h]	
%        \begin{center}
%        \includegraphics[width=1.\linewidth]{discount_interp}
%        \end{center}
%    \end{figure}
%\end{columns}
%\end{frame}

\begin{frame}{Forward Rates}
  \begin{itemize}
  \item A \emph{forward rate} is an interest rate applicable to a financial transaction that will take place in the future.
  \item It can be considered as the \emph{market expectation for future prices} and can serve as an indicator of how it believes will perform.
  \item Contrary the \emph{spot rate} is used by buyers and sellers looking to make an immediate purchase or sale.
  \item To calculate the forward rates exploit no-arbitrage argument:
    \begin{equation}
      \begin{gathered}
        e^{r_1 (t_1-t_0)}e^{r_{1,2}(t_2 - t_1)} = e^{r_2 (t_2-t_0)} \implies e^{r_1 t_1 + r_{1,2}(t_2 - t_1)} = e^{r_2 t_2}, \quad(t_0=0) \\
        r_1 t_1 + r_{1,2}(t_2 - t_1) = r_2 t_2 \implies r_{1,2} = \cfrac{r_2 t_2 - r_1 t_1 }{t_2 - t_1}
      \end{gathered}
    \end{equation}
  \end{itemize}
\end{frame}

\begin{frame}{Forward Rate Class}
  \begin{itemize}
  \item Now let's implement a Forward Rate class. The \textbf{attributes} of this class are
      \begin{itemize}
      \item a set of pillar dates (corresponding to given spot rates), $t_0,...,t_{n}$;
      \item a set of spot rates, $r(t_0),...,r(t_{n})$.
      \end{itemize}
  \item The "behavior" of the object is to return a forward rate given a time interval. We will split it into two methods
    \begin{itemize}
    \item a method to interpolate rate at a given date; 
    \item a method to compute the forward rate relative to a time period.
    \end{itemize}
  \end{itemize}
\href{https://colab.research.google.com/drive/1E-zwmNZ6MSF-I8R2cWvKfPGdmm5SYOMU?authuser=1\#scrollTo=kuN09S2AxZL1}{\beamergotobutton{Forward Rate Class}}
\end{frame}

%\begin{frame}[fragile]{Forward Rate Class}
%\begin{ipython}
%from scipy.interpolate import interp1d
%
%class ForwardRateCurve:
%    def __init__(self, obs_date, pillars, rates):
%        self.obs_date = obs_date
%        pillars = [(p - obs_date).days/365 for p in pillars]
%        self.interpolator = interp1d(pillars, rates)
%    
%    def interp_rate(self, d):
%        d_frac = (d - self.obs_date).days/365
%        if d < self.obs_date or d_frac > self.interpolator.x[-1]:
%            print (f"Cannot extrapolate rates (date: {d}).")
%            return None, None
%        else:
%            return d_frac, self.interpolator(d_frac)
%    ...
%\end{ipython}
%\end{frame}
%
%\begin{frame}[fragile]{Forward Rate Class}
%\begin{ipython}
%    ...
%    def forward_rate(self, d1, d2):
%        d1_frac, r1 = self.interp_rate(d1)
%        d2_frac, r2 = self.interp_rate(d2)
%        if d1_frac is None or d2_frac is None:
%            return None
%        else:
%            return (r2*d2_frac - r1*d1_frac)/(d2_frac - d1_frac)
%\end{ipython}
%\end{frame}
%
%\begin{frame}[fragile]{Testing the Class}
%\begin{ipython}
%from datetime import date
%
%obs_date = date(2020, 1, 1)
%pillars = [date(2020, 1, 1),
%           date(2021, 1, 1),
%           date(2022, 7, 1)]
%rates = [0.0221, 0.0241, 0.0243]
%
%fc = ForwardRateCurve(obs_date, pillars, rates)
%t1 = date(2021, 1, 1)
%t2 = date(2022, 1, 1)
%print (f"F({t1}, {t2}) = {fc.forward_rate(t1, t2):.4f}")
%\end{ipython}
%\begin{ioutput}
%F(2021-01-01, 2022-01-01) = 0.0244
%\end{ioutput}
%\end{frame}

\end{document}
